/*
 * Copyright Â© 2015 The Gravitee team (http://gravitee.io)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.gravitee.apim.archunit;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;

import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.domain.JavaCodeUnit;
import com.tngtech.archunit.core.domain.JavaParameter;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.core.importer.ImportOption;
import com.tngtech.archunit.lang.ArchCondition;
import com.tngtech.archunit.lang.ConditionEvents;
import com.tngtech.archunit.lang.SimpleConditionEvent;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.junit.jupiter.api.DisplayNameGeneration;
import org.junit.jupiter.api.DisplayNameGenerator;
import org.junit.jupiter.api.Test;

/**
 * ArchUnit test to ensure that methods with access to an ExecutionContext
 * use ctx.withLogger(log) instead of calling the Logger directly.
 *
 * @author GraviteeSource Team
 */
@DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)
public class ExecutionContextLoggingArchitectureTest {

    // Packages to check (gateway and plugins only)
    private static final String[] PACKAGES_TO_CHECK = {
        "io.gravitee.gateway.reactive.handlers..",
        "io.gravitee.gateway.reactive.core..",
        "io.gravitee.gateway.reactive.debug..",
        "io.gravitee.apim.plugin..",
        "io.gravitee.plugin.apiservice..",
        "io.gravitee.plugin.entrypoint..",
        "io.gravitee.plugin.endpoint..",
    };

    // Packages to exclude from analysis (API interfaces)
    private static final String[] PACKAGES_TO_EXCLUDE = { "io.gravitee.gateway.reactive.api..", "io.gravitee.gateway.api.." };

    // Classes allowed to use direct Logger calls even with ExecutionContext available.
    // These are typically generated classes that cannot use ctx.withLogger().
    // TODO: *ConfigurationEvaluator classes are generated by gravitee-plugin-annotation-processors.
    //       While this lib is not migrated, we should exclude those classes explicitly.
    private static final Set<String> ALLOW_LIST = Set.of(
        "io.gravitee.plugin.endpoint.http.proxy.configuration.HttpProxyEndpointConnectorConfigurationEvaluator",
        "io.gravitee.plugin.endpoint.http.proxy.configuration.HttpProxyEndpointConnectorSharedConfigurationEvaluator",
        "io.gravitee.plugin.endpoint.tcp.proxy.configuration.TcpProxyEndpointConnectorSharedConfigurationEvaluator"
    );
    // Class name those suffixes that are automatically allowed (generated classes pattern)
    private static final Set<String> ALLOW_LIST_SUFFIXES = Set.of("ConfigurationEvaluator");

    // Type names representing an ExecutionContext
    private static final Set<String> EXECUTION_CONTEXT_TYPE_NAMES = Set.of(
        "BaseExecutionContext",
        "ExecutionContext",
        "HttpExecutionContext",
        "MutableExecutionContext",
        "HttpExecutionContextInternal",
        "HttpPlainExecutionContext",
        "HttpBaseExecutionContext",
        "TcpExecutionContext",
        "MessageExecutionContext"
    );

    // Log methods to detect
    private static final Set<String> LOG_METHODS = Set.of("info", "debug", "error", "warn", "trace");
    public static final String GRAVITEE_APIM_GATEWAY_MODULE = "gravitee-apim-gateway";
    public static final Set<String> MODULES_TO_SCAN = Set.of(GRAVITEE_APIM_GATEWAY_MODULE, "gravitee-apim-plugin");

    @Test
    public void should_use_context_aware_logger_when_execution_context_is_available() {
        JavaClasses importedClasses = importClasses();

        classes()
            .that()
            .resideInAnyPackage(PACKAGES_TO_CHECK)
            .and()
            .resideOutsideOfPackages(PACKAGES_TO_EXCLUDE)
            .should(notCallLoggerDirectlyWhenContextAvailable())
            .check(importedClasses);
    }

    /**
     * Imports classes from target/classes directories of the relevant modules.
     * This approach allows scanning classes even if they are not in the direct classpath.
     */
    private JavaClasses importClasses() {
        // Find the project root directory (gravitee-api-management)
        Path projectRoot = Paths.get("").toAbsolutePath();

        // If we are in a submodule, go up
        while (!Files.exists(projectRoot.resolve(GRAVITEE_APIM_GATEWAY_MODULE)) && projectRoot.getParent() != null) {
            projectRoot = projectRoot.getParent();
        }

        // Collect all existing target/classes directories
        List<Path> classesDirs;
        try {
            Path finalProjectRoot = projectRoot;
            classesDirs = MODULES_TO_SCAN.stream()
                .flatMap(module -> {
                    try {
                        Path moduleDir = finalProjectRoot.resolve(module);
                        if (Files.exists(moduleDir)) {
                            return Files.walk(moduleDir, 10)
                                .filter(p -> p.endsWith("target/classes"))
                                .filter(Files::isDirectory);
                        }
                    } catch (IOException e) {
                        // Ignore access errors
                    }
                    return Stream.empty();
                })
                .collect(Collectors.toList());
        } catch (Exception e) {
            throw new RuntimeException("Unable to scan project modules", e);
        }

        if (classesDirs.isEmpty()) {
            throw new RuntimeException("No target/classes directory found. Make sure you have compiled the project with 'mvn compile'.");
        }

        return new ClassFileImporter().withImportOption(ImportOption.Predefined.DO_NOT_INCLUDE_TESTS).importPaths(classesDirs);
    }

    /**
     * ArchUnit condition that checks if a method has an ExecutionContext parameter,
     * it should not call log methods directly (info, debug, error, warn, trace).
     *
     * Methods that call withLogger() are considered compliant, as the Logger.xxx() call
     * after withLogger() is actually using the context-aware logger.
     *
     * Classes in the ALLOW_LIST or matching ALLOW_LIST_SUFFIXES are excluded from this check.
     */
    private static ArchCondition<JavaClass> notCallLoggerDirectlyWhenContextAvailable() {
        return new ArchCondition<>("not call Logger directly when ExecutionContext is available (use ctx.withLogger(log) instead)") {
            @Override
            public void check(JavaClass javaClass, ConditionEvents events) {
                // Skip classes in the allowed list
                if (isAllowListed(javaClass)) {
                    return;
                }

                // Use getCodeUnits() to get all methods, constructors, and static initializers
                for (JavaCodeUnit codeUnit : javaClass.getCodeUnits()) {
                    // Check if the code unit has an ExecutionContext parameter
                    boolean hasExecutionContextInParams = codeUnit.getParameters().stream().anyMatch(this::isExecutionContextType);

                    if (hasExecutionContextInParams) {
                        // Check if the method calls withLogger() - if so, it's using the context-aware logger correctly
                        boolean usesWithLogger = codeUnit
                            .getMethodCallsFromSelf()
                            .stream()
                            .anyMatch(call -> "withLogger".equals(call.getTarget().getName()));

                        if (usesWithLogger) {
                            // Method uses withLogger(), so Logger.xxx() calls are from the context-aware logger
                            continue;
                        }

                        // No withLogger() call found - check for direct Logger calls
                        codeUnit
                            .getMethodCallsFromSelf()
                            .stream()
                            .filter(call -> isLoggerType(call.getTargetOwner()))
                            .filter(call -> LOG_METHODS.contains(call.getTarget().getName()))
                            .forEach(call -> {
                                String message = String.format(
                                    "Method [%s] in class [%s] calls Logger.%s() directly. " +
                                        "Use 'ctx.withLogger(log).%s(...)' to include request context in logs.",
                                    codeUnit.getName(),
                                    javaClass.getName(),
                                    call.getTarget().getName(),
                                    call.getTarget().getName()
                                );
                                events.add(SimpleConditionEvent.violated(javaClass, message));
                            });
                    }
                }
            }

            /**
             * Checks if the class is in the allow list (either by exact FQCN match or by suffix pattern).
             */
            private boolean isAllowListed(JavaClass javaClass) {
                String className = javaClass.getName();

                // Check explicit allow list
                if (ALLOW_LIST.contains(className)) {
                    return true;
                }

                // Check suffix patterns (e.g., *ConfigurationEvaluator)
                String simpleName = javaClass.getSimpleName();
                return ALLOW_LIST_SUFFIXES.stream().anyMatch(simpleName::endsWith);
            }

            /**
             * Checks if the parameter is an ExecutionContext type based on the type name.
             */
            private boolean isExecutionContextType(JavaParameter parameter) {
                String typeName = parameter.getRawType().getSimpleName();
                // A provided set of interface name is provided, but we ensure it with a suffix verification
                return EXECUTION_CONTEXT_TYPE_NAMES.contains(typeName) || typeName.endsWith("ExecutionContext");
            }

            /**
             * Checks if the type is an SLF4J Logger.
             */
            private boolean isLoggerType(JavaClass targetOwner) {
                return targetOwner.isAssignableTo("org.slf4j.Logger");
            }
        };
    }
}
