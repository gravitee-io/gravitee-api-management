# Default values for gravitee.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
common:
  labels: {}
  annotations: {}

# -- Array of extra K8s manifests to deploy
extraObjects: []
  #- apiVersion: v1
  #  kind: Secret
  #  metadata:
  #    name: gravitee-license
  #    namespace: graviteeio
  #  type: Opaque
  #  data:
  #    license.key: myLicenceInBase64==

installation:
  type: standalone
  api:
    url:
  standalone:
# If you want to use multiple environments with different consoles/portals, you can configure the URL below.
    console:
      urls:
#        - orgId: DEFAULT
#          url: https://4-2-x-multi-console.console1.team-apim.gravitee.dev
#        - orgId: 6eb27b47-2560-481f-b27b-472560581fff
#          url: https://4-2-x-multi-console.console2.team-apim.gravitee.dev
    portal:
      urls:
#        - envId: DEFAULT
#          url: https://4-2-x-multi-console.portal1.team-apim.gravitee.dev
#        - envId: 808a51a9-48f5-4517-8a51-a948f5e517b3
#          url: https://4-2-x-multi-console.portal2.team-apim.gravitee.dev

# Create NetworkPolicy objects
# https://kubernetes.io/docs/concepts/services-networking/network-policies/
networkPolicy:
#  podSelector:
#    matchExpressions:
#      - key: app.kubernetes.io/component
#        operator: In
#        values: [ "gateway", "api", "ui", "portal" ]
#  policyTypes:
#    - Egress
#  egress:
#    - to:
#        - ipBlock:
#            cidr: 0.0.0.0/0
#            except:
#              - 169.254.169.254/32

apim:
  name: apim
  # Whether this chart should self-manage its service account, role, and associated role binding.
  managedServiceAccount: true

  # Custom service account override that the pod will use
  # if customer provides a dedicated SA for any component, that will have the priority
  serviceAccount: ""

  roleRules:
    - apiGroups:
        - ""
      resources:
        - configmaps
        - secrets
      verbs:
        - get
        - list
        - watch
  # Whether you want to run the APIM in DB less mode. If ste to true, it will disable both UIs and also Management API components
  # Only Gateway will be deployed to the cluster in DB less mode
  dbLess: false

  kubernetes:
    projection:
      enabled: false
      expirationSeconds: 2592000
      audience: vault

chaos:
  enabled: false

graviteeRepoAuth:
  enabled: true

inMemoryAuth:
  enabled: true
  allowEmailInSearchResults: false
  passwordEncodingAlgo: bcrypt

jwtSecret: myJWT4Gr4v1t33_S3cr3t

# Define extra inMemory users here or disable the default ones here
# By default, admin user will be added. If you want to remove the default admin turn the followong boolean to false.
adminAccountEnable: true
# Default password "admin", use bcrypt ($2a$ version) to generate a new one
adminPasswordBcrypt: $2a$10$Ihk05VSds5rUSgMdsMVi9OKMIx2yUvMz7y9VP3rJmQeizZLrhLMyq
adminEmail:
adminFirstName:
adminLastName:

extraInMemoryUsers: |
  - user:
    username: user
    # Password value: password
    password: $2a$10$9kjw/SH9gucCId3Lnt6EmuFreUAcXSZgpvAYuW2ISv7hSOhHRH1AO
    roles: ORGANIZATION:USER, ENVIRONMENT:USER
    # Useful to receive notifications
    #email:
    #firstName:
    #lastName:
  - user:
    username: api1
    # Password value: api1
    password: $2a$10$iXdXO4wAYdhx2LOwijsp7.PsoAZQ05zEdHxbriIYCbtyo.y32LTji
    # You can declare multiple roles using comma separator
    roles: ORGANIZATION:USER, ENVIRONMENT:API_PUBLISHER
    #email:
    #firstName:
    #lastName:
  - user:
    username: application1
    # Password value: application1
    password: $2a$10$2gtKPYRB9zaVaPcn5RBx/.3T.7SeZoDGs9GKqbo9G64fKyXFR1He.
    roles: ORGANIZATION:USER, ENVIRONMENT:USER
    #email:
    #firstName:
    #lastName:

ldap:
  enabled: false
  context:
    # User to bind the LDAP
    user: user@example.com
    # Password to bind the LDAP
    password: pass@12345
    # URL to LDAP
    url: ldap://ldap.example.com
    # Bind base to be used in authentication and lookup sections
    base: dc=example,dc=com
  authentication:
    user:
      # Base to search users, must be relative to the context.base
      base: ou=users
      # Use sAMAccountName if you are in AD
      # Use uid if you are in a native LDAP
      # The {0} will be replaced by user typed to authenticate
      filter: sAMAccountName={0}
      # If you have an attribute with the user photo, you can set it here
      photo: "thumbnailPhoto"
    group:
      # Base to search groups, must be relative to the context.base
      # There an issue here, until fixed only oneleve search is supported
      base: ou=gravitee,ou=groups
      # The {0} will be replaced by DN of the user
      filter: member={0}
      role:
        # The attribute that define your group names on your AD/LDAP
        # You can use sAMAccountName if you're in AD or cn if you're in native LDAP
        attribute: sAMAccountName
        consumer: LDAP_GROUP_CONSUMER
        publisher: LDAP_GROUP_PUBLISHER
        admin: LDAP_GROUP_ADMIN
        user: LDAP_GROUP_USER
  lookup:
    allowEmailInSearchResults: false
    # Note that personal information can be exposed without user consentment
    user:
      # Base to lookup user, must be relative to context.base
      base: ou=users
      # The filter can be any type of complex LDAP query
      filter: (&(objectClass=person)(|(cn=*{0}*)(sAMAccountName={0})))
security:
  trustAll: false
  providers: []
oidcAuth:
  enabled: false
#  id: keycloak
#  clientId:
#  clientSecret:
#  tokenIntrospectionEndpoint:
#  tokenEndpoint:
#  authorizeEndpoint:
#  userInfoEndpoint:
#  userLogoutEndpoint:
#  color:
#  syncMappings:
#  scopes:
#    - openid
#    - profile
#  userMapping:
#    id: sub
#    email: email
#    lastname: family_name
#    firstname: given_name
#    picture: picture
#  groupMapping:
#    - condition: "{#jsonPath(#profile, '$.realm_roles').contains('group1')}"
#      groups:
#        - Group 1
#        - Group 2
#  roleMapping:
#    - condition: "{#jsonPath(#profile, '$.realm_roles').contains('admin')}"
#      roles:
#        - "ENVIRONMENT:ADMIN"
#        - "ORGANIZATION:ADMIN"
smtp:
  enabled: true
#  host: smtp.example.com
#  port: 25
#  from: info@example.com
#  username: info@example.com
#  password: example.com
#  subject: "[gravitee] %s"
#  properties:
#    auth: true
#    starttls.enable: false
#    localhost: apim.example.com

notifiers:
  smtp:
    enabled: true
    host: ${email.host}
    subject: ${email.subject}
    port: ${email.port}
    from: ${email.from}
    username: ${email.username}
    password: ${email.password}
    # starttlsEnabled: false
    # ssl:
    #   trustAll: false
    #   keyStore:
    #   keyStorePassword:

mongo:
  # uri: mongodb://graviteeio-apim-mongodb-replicaset-headless:27017/gravitee?replicaset=rs0&connectTimeoutMS=30000
  # servers: |
  #   - host: mongo1
  #     port: 27017
  #   - host: mongo2
  #     port: 27017
  sslEnabled: false
  socketKeepAlive: false
  rs: rs0
  rsEnabled: true
  dbhost: graviteeio-apim-mongodb-replicaset-headless
  dbname: gravitee
  dbport: 27017
  connectTimeoutMS: 30000
  auth:
    enabled: false
    source: admin
    username:
    password:

jdbc:
  url: jdbc:mysql://localhost:3306/gravitee
  # the URL to download the driver
  driver: https://repo1.maven.org/maven2/mysql/mysql-connector-java/8.0.22/mysql-connector-java-8.0.22.jar
  # the version of the gravitee-repository-jdbc (only required for apim versions < 3.5.0)
#  repositoryVersion: 3.3.0
  username:
  password:
  liquibase: true
  schema: public
  pool:
    autoCommit:  true
    connectionTimeout: 10000
    idleTimeout: 600000
    maxLifetime: 1800000
    minIdle: 10
    maxPoolSize: 10
    registerMbeans: true

# Configuration to download the gravitee-apim-repository-redis plugin if rate-limit is configured to use Redis
redis:
  # By default, the Helm will create init containers for downloading and mounting the Redis plugin as an init container.
  # Set to false if you're looking to manage Redis plugin by yourself
  download: true
#  repositoryVersion: 3.3.0

mongodb:
  enabled: false
  architecture: replicaset
  fullnameOverride: "graviteeio-apim-mongodb-replicaset"
  replicaSetName: rs0
  podAffinityPreset: soft
  image:
    repository: bitnamilegacy/mongodb
    tag: 6.0.13
  auth:
    enabled: false
  resources:
    limits:
      cpu: 1
      memory: 512Mi
    requests:
      cpu: 100m
      memory: 256Mi
  persistence:
    enabled: true
    # storageClass: ""
    accessModes:
      - ReadWriteOnce
    size: 1Gi
  # For Openshift user, you can enforce the compatibility (default: auto)
#  global:
#    compatibility:
#      openshift:
#        adaptSecurityContext: force

es:
  enabled: true
  cluster: elasticsearch
  index: gravitee
  # If the details for security are entered
  # authentication will be provided for the
  # elastic search cluster
  # https://documentation.gravitee.io/apim/getting-started/configuration/configure-repositories/elasticsearch#apim-api-configuration
  index_mode: daily # Index mode normal (daily index) vs ILM (managed by ILM)
  settings:
    number_of_shards: 1
    number_of_replicas: 1
    refresh_interval: 5s
  security:
    enabled: false
    username: example
    password: example
  lifecycle:
    enabled: false
    policyPropertyName: index.lifecycle.name   #for Opensearch, use 'index.plugins.index_state_management.policy_id' instead of 'index.lifecycle.name'
    rolloverAliasPropertyName: index.lifecycle.rollover_alias   #for Opensearch, use 'index.plugins.index_state_management.rollover_alias' instead of 'index.lifecycle.name'
    policies:
      monitor: my_policy ## ILM policy for the gravitee-monitor-* indexes
      request: my_policy ## ILM policy for the gravitee-request-* indexes
      health: my_policy ## ILM policy for the gravitee-health-* indexes
      log: my_policy ## ILM policy for the gravitee-log-* indexes
    # http:
      # timeout: 10000
  ssl:
    enabled: false
    # keystore:
    #   type: jks
    #   path: path/to/jks
    #   password: example
    #   certs:
    #     - /path/to/cert1
    #     - /path/to/cert2
    #   keys:
    #     - /path/to/key
    #     - /path/to/key2
  endpoints:
    - http://graviteeio-apim-elasticsearch-ingest-hl:9200
  pipeline:
    plugins:
      ingest: geoip, user_agent # geoip and user_agent plugins are enabled by default

elasticsearch:
  enabled: false
  name: "elasticsearch"
  fullnameOverride: "graviteeio-apim-elasticsearch"
  image:
    repository: "bitnamilegacy/elasticsearch"
    tag: "8.17.4"
  master:
    replicaCount: 2
    persistence:
      size: 4Gi
    resources:
      limits:
        cpu: 500m
        memory: 1024Mi
      requests:
        cpu: 25m
        memory: 256Mi
  coordinating:
    replicaCount: 2
    resources:
      limits:
        cpu: 500m
        memory: 1024Mi
      requests:
        cpu: 25m
        memory: 256Mi
  data:
    replicaCount: 2
    heapSize: 512m
    resources:
      limits:
        cpu: 1
        memory: 2048Mi
      requests:
        cpu: 50m
        memory: 1024Mi
    persistence:
      size: 20Gi
  # For Openshift user, you can enforce the compatibility (default: auto) and need to disable sysctlImage
#  global:
#    compatibility:
#      openshift:
#        adaptSecurityContext: force
#  sysctlImage:
#    enabled: false

alerts:
  enabled: false
  endpoints:
    - http://localhost:8072/
  security:
    enabled: false
    username: admin
    password: adminadmin

management:
  type: mongodb
  #url: your_public_ui_url

ratelimit:
  type: mongodb

# Support for Gravitee.io Cockpit (cockpit.gravitee.io)
cockpit:
  enabled: false
  keystore:
    value: "base64 encoded value of the keystore provided by Cockpit (required)"
    password:
  #  value: "keystores password provided by Cockpit"
  #  valueFrom:
  #    secretKeyRef:
  #    configMapKeyRef:
  #truststore:
  #  value: base64 encoded value of the truststore provided by Cockpit (optional)
  #  password:
  #    value: "truststore password provided by Cockpit"
  #    valueFrom:
  #      secretKeyRef:
  #      configMapKeyRef:
  url: https://cockpit.gravitee.io
  controller: https://cockpit-controller.gravitee.io
  ssl:
    verifyHostname: true

# Support for Gravitee.io Cloud (cloud.gravitee.io)
cloud:
  enabled: false
  url: https://cloud.gravitee.io
  connector:
    ws:
      endpoints:
        - https://cloud-controller.gravitee.io
      ssl:
        verifyHost: true
        keystore:
          type: pkcs12
          path: /opt/graviteeio-management-api/cloud/keystore.p12
          password:
          #  value: "keystores password provided by Cockpit"
          #  valueFrom:
          #    secretKeyRef:
          #    configMapKeyRef:
        truststore:
          type: pkcs12
          path: /opt/graviteeio-management-api/cloud/truststore.p12
          password:
          #  value: "truststore password provided by Cockpit"
          #  valueFrom:
          #    secretKeyRef:
          #    configMapKeyRef:

cluster:
  plugins:
    - https://download.gravitee.io/pre-releases/plugins/node-cache/gravitee-node-cache-plugin-hazelcast/gravitee-node-cache-plugin-hazelcast-8.0.0-alpha.4.zip
    - https://download.gravitee.io/pre-releases/plugins/node-cluster/gravitee-node-cluster-plugin-hazelcast/gravitee-node-cluster-plugin-hazelcast-8.0.0-alpha.4.zip

api:
  enabled: true
  upgrader: false
  name: api
  logging:
    debug: false
    contextualLoggingEnabled: false
    stdout:
      json: false
      encoderPattern: "%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
      contextualLoggingEncoderPattern: "%d{HH:mm:ss.SSS} [%thread] [%X{orgId} %X{envId}] %-5level %logger{36} - %msg%n"
    file:
      enabled: false
      rollingPolicy: |
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- daily rollover -->
            <fileNamePattern>${gravitee.home}/logs/gravitee_%d{yyyy-MM-dd}.log</fileNamePattern>
            <!-- keep 30 days' worth of history -->
            <maxHistory>30</maxHistory>
        </rollingPolicy>
      encoderPattern: "%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n%n"
      contextualLoggingEncoderPattern: "%d{HH:mm:ss.SSS} [%thread] [%X{orgId} %X{envId}] %-5level %logger{36} - %msg%n%n"
    graviteeLevel: DEBUG
    jettyLevel: INFO
  restartPolicy: OnFailure
  # If you provide your own gravitee.yml by using a volumeMount, reloadOnConfigChange is disabled.
  reloadOnConfigChange: true
  deployment:
    # Annotations to apply to the deployment
    annotations: {}
    # additionals labels
    labels: {}
    affinity: {}
    hostAliases: []
    #- ip: "127.0.0.1"
    #  hostnames:
    #  - "foo.local"
    #  - "bar.local"
    nodeSelector: {}
    tolerations: []
    envFrom: []
    # - configMapRef:
    #     name: config-secret
    # SecurityContext holds pod-level security attributes and common container settings.
    # Field values of container.securityContext take precedence over field values of PodSecurityContext.
    podSecurityContext:
      #fsGroup: 1001
      #runAsUser: 1001
      #runAsNonRoot: true
    # SecurityContext defines the security options the container should be run with.
    # If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext
    securityContext:
      runAsUser: 1001
      runAsNonRoot: true

    # Dedicated Service account provided for this component
    serviceAccount: ""
    strategy:
      type: RollingUpdate
      rollingUpdate:
        maxUnavailable: 1
    topologySpreadConstraints: []
    # revisionHistoryLimit: 10

    livenessProbe:
      enabled: true
      tcpSocket:
        port: http
      initialDelaySeconds: 30
      periodSeconds: 30
      failureThreshold: 3

    customLivenessProbe: {}

    readinessProbe:
      enabled: true
      tcpSocket:
        port: http
      initialDelaySeconds: 30
      periodSeconds: 30
      failureThreshold: 3

    customReadinessProbe: {}

    startupProbe:
      enabled: true
      tcpSocket:
        port: http
      failureThreshold: 30
      periodSeconds: 10

    customStartupProbe: {}
  # configuration reflects the parameters keys
  configuration:
    logging: {}
#      messageSampling:
#        count:
#          default: 500
#          limit: 100
#        probabilistic:
#          default: 0.01
#          limit: 0.5
#        temporal:
#          default: PT1S
#          limit: PT1S

  pdb:
    enabled: false
    minAvailable: ""
    maxUnavailable: "50%"

  podAnnotations: {}
    # iam.amazonaws.com/role: es-cluster

  # How long to wait for APIM Management API pods to stop gracefully
  terminationGracePeriod: 30

  # This is the PriorityClass settings as defined in
  # https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass
  priorityClassName: ""

  updateStrategy:
    rollingUpdate:
      maxUnavailable: 1
    type: RollingUpdate
  replicaCount: 1
  image:
    repository: graviteeio/apim-management-api
    # tag: 3.0.2
    pullPolicy: Always
    # pullSecrets: gravitee_secrets
  env: []
  #   - name: ENV_VARIABLE
  #     value: ENV_VARIABLE_VALUE
  #   - name: ENV_VARIABLE_WITH_FROM
  #     valueFrom:
  #       configMapKeyRef:
  #         name: special-config
  #         key: SPECIAL_LEVEL
  additionalPlugins:
#    - https://path_to_plugin
  ssl:
    enabled: false
  #  keystore:
  #    type: jks # Supports jks, pkcs12
  #    path: ${gravitee.home}/security/keystore.jks
  #    password: secret
  #  truststore:
  #    type: jks # Supports jks, pkcs12
  #    path: ${gravitee.home}/security/truststore.jks
  #    password: secret
  services:
    metrics:
      enabled: false
      prometheus:
        enabled: true
        concurrencyLimit: 3
    bridge:
      enabled: false
      # host: localhost
      # # next two are deprecated, use authentication.users instead
      # username:
      # password:
      tcpKeepAlive: true
      # maxHeaderSize: 8192
      # maxChunkSize: 8192
      # alpn: true
      # authentication:
      #    type: basic # Supports: none, jwt
      #    users:
      #      admin: secret
      #      foo: bar
      #    jwt:
      #      signature:
      #        algorithm: RS256
      #        path: ${gravitee.home}/security/bridge/public_key.pem
      #        # path and value mutually exclusive
      #        value: <public key pem with headers>
      #      verifyClaims: true
      ssl:
        enabled: false
      #  keystore:
      #    type: jks # Supports jks, pem, pkcs12
      #    path: ${gravitee.home}/security/keystore.jks
      #    password: secret
      #    defaultAlias:
      #    secret: secret://kubernetes/bridge-tls
      #    watch: true
      #    # when type is 'pem'
      #    certificates:
      #      - cert: ${gravitee.home}/security/cert.pem
      #        key: ${gravitee.home}/security/key.pem
      #  clientAuth: none
      #  truststore:
      #    type: jks # Supports jks, pem, pkcs12
      #    path: ${gravitee.home}/security/truststore.jks
      #    password: secret
      #    secret: secret://kubernetes/bridge-mtls:ca.crt
      #    watch: true
      service:
        externalPort: 92
        internalPort: 18092
      #  appProtocol: http
      ingress:
        enabled: false
        ingressClassName: ""
        pathType: Prefix
        path: /api/_bridge
        # Used to create an Ingress record.
        hosts:
          - apim.example.com
        annotations: {}
        #  kubernetes.io/ingress.class: nginx
        #  nginx.ingress.kubernetes.io/ssl-redirect: "false"
        #  nginx.ingress.kubernetes.io/enable-rewrite-log: "true"
        #  kubernetes.io/app-root: /api
        #  kubernetes.io/rewrite-target: /api
        #  nginx.ingress.kubernetes.io/configuration-snippet: "etag on;\nproxy_pass_header ETag;\nproxy_set_header if-match \"\";\n"
        #  kubernetes.io/tls-acme: "true"
        # tls:
          # Secrets must be manually created in the namespace.
        #  - hosts:
        #      - apim.example.com
        #    secretName: api-custom-cert
    subscription:
      enabled: false
#      pre-expiration-notification-schedule: 15,10,5
  http:
    services:
      core:
        http:
          enabled: true
          port: 18083
          host: localhost
          authentication:
            password: adminadmin
        ingress:
          enabled: false
          ingressClassName: ""
          pathType: Prefix
#          path: /management/_(.*)
#          hosts:
#            - apim.example.com
#          annotations:
#            kubernetes.io/ingress.class: nginx
#            nginx.ingress.kubernetes.io/rewrite-target: /_$1
        service:
#       If you choose to enable this service, you'll need to expose the technical api
#       on an accessible host outside of the pod: api.http.services.core.http.host
          enabled: false
#         type: ClusterIP
#         externalPort: 18083
#         appProtocol: http
    api:
      entrypoint: /
    secureHeaders:
      csrf:
        # Allows to enable or disable the CSRF protection. Enabled by default.
        enabled: true
      hsts:
        enabled: true
        include-sub-domains: true
        max-age: 31536000

      # Adds the X-Frame-Options header. Possible values: DENY, SAMEORIGIN. Enabled by default on SAMEORIGIN.
      xframe:
        enabled: true
        action: SAMEORIGIN

      # Adds the X-Content-Type-Options: nosniff header. Enabled by default.
      xContentTypeOptions:
        enabled: true

      # Adds the Content-Security-Policy header.
      # Example: "default-src 'self'; frame-ancestors 'none';"
      csp:
        policy: "frame-ancestors 'self';"

      # Adds the Referrer-Policy header.
      # Example: "no-referrer", "strict-origin-when-cross-origin", ...
      referrerPolicy:
        policy: "strict-origin-when-cross-origin"

      # Adds the Permissions-Policy header.
      # Example: "geolocation=(), microphone=(), camera=()"
      permissionsPolicy:
        policy: "geolocation=(), microphone=(), camera=()"
    client:
      timeout: 10000
      # proxy:
      #   type: HTTP
      #   excludeHosts:
      #     - '*.internal.com'
      #     - 'internal.mycompany.com'
      #   http:
      #     host: localhost
      #     port: 3128
      #     username:
      #     password:
      #   https:
      #     host: localhost
      #     port: 3128
      #     username:
      #     password:
  user:
    login:
      defaultApplication: true
    anonymizeOnDelete: false
  supportEnabled: true
  ratingEnabled: true
  newsletterEnabled: true
  # Specify the visibility duration of a gateway in Unknown State (in seconds)
  gateway:
    unknownExpireAfter: 604800
  service:
    type: ClusterIP
    # externalTrafficPolicy is used only when configuring type "NodePort" or "LoadBalancer"
    externalTrafficPolicy: Cluster
    externalPort: 83
    internalPort: 8083
    # used only if the type of your service is "NodePort" and must be in the range 30000-32767
    # if not set a random port will be used in that range
    # nodePort: 30083
    internalPortName: http
#    appProtocol: http
  # annotations:
  autoscaling:
    # When api.autoscaling.enabled is true, a HorizontalPodAutoscaler is created
    enabled: true
    minReplicas: 1
    maxReplicas: 3
    # warning: these two target utilization will be overwritten if api.autoscaling.metrics is defined.
    targetAverageUtilization: 50
    targetMemoryAverageUtilization: 80
    # here you can add specific annotations to this HPA
#    annotations:
    # If default CPU and Memory utilisation is not enough, you can here overwrite the metrics with your settings
    # @see: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
#    metrics:
    # Optionnaly you can also add behavior
    # @see: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#configurable-scaling-behavior
#    behavior:
  ingress:
    management:
      enabled: true
      scheme: https # should be https or http
      pathType: Prefix
      path: /management
      ingressClassName: ""
      # Used to create an Ingress record.
      hosts:
        - apim.example.com
      annotations:
        kubernetes.io/ingress.class: nginx
        #nginx.ingress.kubernetes.io/configuration-snippet: "etag on;\nproxy_pass_header ETag;\nproxy_pass_header if-match;\n"
        # kubernetes.io/tls-acme: "true"
      # tls:
        # Secrets must be manually created in the namespace.
      #  - hosts:
      #      - apim.example.com
      #    secretName: api-custom-cert
    portal:
      enabled: true
      scheme: https # should be https or http
      pathType: Prefix
      path: /portal
      ingressClassName: ""
      # Used to create an Ingress record.
      hosts:
        - apim.example.com
      annotations:
        kubernetes.io/ingress.class: nginx
        # kubernetes.io/tls-acme: "true"
      # tls:
        # Secrets must be manually created in the namespace.
      #  - hosts:
      #      - apim.example.com
      #    secretName: api-custom-cert
    automation:
      enabled: false
      path: /automation
      ingressClassName: ""
      pathType: Prefix
      hosts:
        - apim.example.com
      tls:
        - hosts:
            - apim.example.com
          secretName: apim.example.com
      annotations:
        kubernetes.io/ingress.class: nginx
  resources:
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    limits:
      cpu: 500m
      memory: 1024Mi
    requests:
      cpu: 200m
      memory: 512Mi
    #  lifecycle:
    #    postStart: '[ "/bin/sh", "-c", "echo Post starting Gravitee Management API" ]'
    #    preStop: '[ "/bin/sh", "-c", "echo Pre stopping Gravitee Management API" ]'
    ## Additional gravitee API volume mounts
    # Defines additional volume mounts.
    # extraVolumeMounts: |
    # - name: extra-volume
    #   mountPath: /mnt/volume
    #   readOnly: true
  # If you want to use your own gravitee.yml you have to provide your configmap or secret in extraVolume part.
  # the name of the volume MUST be "config".
  # In this case, values configuration related to gravitee.yaml defined in this file will be ignored
  #extraVolumes: |
  #  - name: config
  #    configMap:
  #      name: gravitee-config-configmap-name
  #  - name: config
  #    secret:
  #      secretName: gravitee-config-secret-name

  # you can choose if you want to enable analytics using elasticsearch or disable it (set type to "none")
  analytics:
    type: elasticsearch # or none

  # External Authentication settings
  #  auth:
  #    external:
  #      enabled: false
  #      algorithm: HS256
  #      verificationKey: ozhbx5HJCS41NzKrBSQ0vZU1WOmG0Uhm # verificationKey or the JWKS URL
  #      issuer: MY_ISSUER
  newtai:
    elgen:
      enabled: false

  federation:
    enabled: false
    port: 8072
    ingress:
      enabled: true
      ingressClassName: ""
      path: /integration-controller(/.*)?
      pathType: ImplementationSpecific
#      hosts:
#        - apim.example.com
      annotations:
        kubernetes.io/ingress.class: nginx
        nginx.ingress.kubernetes.io/proxy-read-timeout: 3600                                                                                                                                              â”‚
        nginx.ingress.kubernetes.io/proxy-send-timeout: 3600
        nginx.ingress.kubernetes.io/rewrite-target: /$1
#      tls:
#        - hosts:
#            - apim.example.com
#          secretName: api-custom-cert
    service:
      externalPort: 72

gateway:
  enabled: true
  # if enabled, required annotation will be added to allow the gateway to act as a runtime for the GKO
  # ingress controller (service should be set to type LoadBalancer in order to get the full feature set)
  ingressController:
    enabled: false # this is the default
    ingressClassName: graviteeio # this is the default
  # if enabled, the gateway will run without any database meaning that kubernetes sync should be enabled
  # to retrieve api definitions from config maps
  dbLess: false
  type: Deployment
  name: gateway

  # Distributed sync configuration (requires replicaCount > 1)
  # Uncomment below for Hazelcast cluster cache synchronization
#  cluster:
#    type: hazelcast
#    hazelcast:
#      configPath: /opt/graviteeio-gateway/config/hazelcast.xml

  # Uncomment below to enable Redis-based distributed sync
#  distributedSync:
#    enabled: true
#    type: redis
#    redis:
#      host: redis
#      port: 6379
#      # Authentication
#      username:
#      password:
#      # SSL configuration
#      ssl: false
#      hostnameVerificationAlgorithm: NONE
#      trustAll: true
#      tlsProtocols: TLSv1.2
#      tlsCiphers:
#      alpn: false
#      openssl: false
#      # Keystore configuration for client certificates
#      keystore:
#        type: pem
#        path: ${gravitee.home}/security/redis-keystore.jks
#        password:
#        keyPassword:
#        alias:
#        certificates: []
#        #  - cert: ${gravitee.home}/security/redis-mycompany.org.pem
#        #    key: ${gravitee.home}/security/redis-mycompany.org.key
#      # Truststore configuration
#      truststore:
#        type: pem
#        path: ${gravitee.home}/security/redis-truststore.jks
#        password:
#        alias:
#      # Sentinel configuration for high availability
#      sentinel:
#        master:
#        nodes: []
#        #  - host: sentinel1
#        #    port: 26379
#      # Timeout configuration
#      operation:
#        timeout: 10
#      tcp:
#        connectTimeout: 5000
#        idleTimeout: 0
  # Note: Also uncomment 'repository' and 'distributed' in services.sync section below (around line 1475)
  # you can pass a list of bot http and tcp servers in here so the gateway will use this setting to setup its internal servers
#  servers:
#    - type: http # tcp
#      port: 8082
#      #idleTimeout: 0
#      #tcpKeepAlive: true
#      #compressionSupported: false
#      maxHeaderSize: 8192
#      maxChunkSize: 8192
#      maxInitialLineLength: 4096
#      maxFormAttributeSize: 2048
#      instances: 0
#      requestTimeout: 0 (in v4 mode, default is 30_000 ms)
#      # The following is only used in v4 engine. It represents the maximum delay to let the response's platform flows execute properly in case of error during the previous phases.
#      # It's configures a timeout from the max between (requestTimeout - api elapsed time) and requestTimeoutGraceDelay.
#      requestTimeoutGraceDelay: 30
#      secured: false
#      alpn: false
#      ssl:
#        clientAuth: none # Supports none, request, required
#        tlsProtocols: TLSv1.2, TLSv1.3
#        tlsCiphers: TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
#        keystore:
#          type: jks # Supports jks, pem, pkcs12, self-signed
#          path: ${gravitee.home}/security/keystore.jks # A path is required if certificate's type is jks or pkcs12
#          password: secret
#          watch: true # Watch for any updates on the keystore and reload it. Default is true.
#          # The following is for type 'pem', report to 'secrets' section for other secret-provider plugins.
#          # This method is now the preferred way for kubernetes: /namespace/secrets/my-tls-secret
#          secret: secret://kubernetes/my-tls-secret
#        truststore:
#          type: jks # Supports jks, pem, pkcs12, pem-folder (for the latter watch supports added/updated/removed files)
#          path: ${gravitee.home}/security/truststore.jks
#          password: secret
#          watch: true # Watch for any updates on the keystore and reload it. Default is true.
#        sni: false
#        openssl: false # Used to rely on OpenSSL Engine instead of default JDK SSL Engine
#      websocket:
#        enabled: false
#        subProtocols: v10.stomp, v11.stomp, v12.stomp
#        perMessageWebSocketCompressionSupported: true
#        perFrameWebSocketCompressionSupported: true
#        maxWebSocketFrameSize: 65536
#        maxWebSocketMessageSize: 262144 # 4 full frames worth of data
#      haproxy: # Support for https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt
#        proxyProtocol: false
#        proxyProtocolTimeout: 10000
#          # in the case of having multiple servers configured, this can be used for mapping the ports
#      service:
#        type: ClusterIP
#        externalPort: 82
#        # used only if the type of your service is "NodePort" and must be in the range 30000-32767
#        # if not set a random port will be used in that range
#        nodePort: 30082
#        internalPortName: http
#        appProtocol: http
#      ingress:
#        enabled: true
#        pathType: Prefix
#        path: /
#        ingressClassName: ""
#        # Used to create an Ingress record.
#        # Multiple hostnames supported
#        # - hosts:
#        #     - chart-example.local
#        #     - chart-example2.local
#        hosts:
#          - apim.example.com
#        annotations:
#          kubernetes.io/ingress.class: nginx
#          nginx.ingress.kubernetes.io/ssl-redirect: "false"
#          # nginx.ingress.kubernetes.io/configuration-snippet: "etag on;\nproxy_pass_header ETag;\nproxy_set_header if-match \"\";\n"
#          # kubernetes.io/tls-acme: "true"
##        tls:
##          # Secrets must be manually created in the namespace.
##          - hosts:
##            - apim.example.com
##            secretName: api-custom-cert
  http:
    maxHeaderSize: 8192
    maxChunkSize: 8192
    maxInitialLineLength: 4096
    maxFormAttributeSize: 2048
    alpn: "true"
    requestTimeout: 30000
    requestTimeoutGraceDelay: 30

# # Gateway Kafka server
#  kafka:
#    enabled: false
#
#    routingMode: host # default is host. Only host is supported for now.
#    # Routing Host Mode
#    routingHostMode:
#      brokerPrefix: broker-          # default is broker-
#      domainSeparator: -             # Used to separate broker's name from api & defaultDomain. Default is '-'
#
#      # The default domain where the Kafka APIs are exposed. ex: `myapi` will be exposed as `myapi.mycompany.org`
#      defaultDomain: mycompany.org   # Should set according to the public wildcard DNS/Certificate. Default is empty
#      defaultPort:   9092            # Default public port for Kafka APIs. Default is 9092
#
#      # With the upper default configuration, the Gravitee Kafka gateway yields bootstrap and broker domains to be as follows:
#      bootstrapDomainPattern: {apiHost}.mycompany.org
#      brokerDomainPattern: broker-{brokerId}-{apiHost}.mycompany.org
#      # Where:
#      # {apiHost}  is a placeholder that will be replaced when the API is deployed, by the API Host Prefix.
#      # {brokerId} is a placeholder that stands for the broker id
#
#      # It can be overridden to fit your DNS configuration.
#      # Doing so requires BOTH patterns to be set, as well as 'defaultPort'. Please note that 'defaultDomain', 'brokerPrefix' and 'domainSeparator' are not used in that case, hence optional.
#      # Example:
#      #   defaultPort: 9092
#      #   bootstrapDomainPattern: bootstrap-{apiHost}.mycompany.org
#      #   brokerDomainPattern: {apiHost}-broker{brokerId}.mycompany.org
#      #
#      #   This configuration yields domains that must target the Gravitee Kafka gateway:
#      #      bootstrap-myapi.mycompany.org
#      #      myapi-broker0.mycompany.org
#      #      myapi-broker1.mycompany.org
#      #      ...
#
#    # Kafka probe
#    probe:
#      # When protocol is tcp, the probe only checks the kafka port is listening by attempting a basic TCP connection (default).
#      # When protocol is kafka, the probe uses a kafka client library to connect to one of the kafka API deployed on this gateway instance.
#      protocol: tcp
#      # When using kafka protocol, you must provide the kafka properties with the connection info.
#      properties:
#        bootstrap.servers: bootstrap-myapi.mycompany.org:9092
#        sasl.mechanism: PLAIN
#        security.protocol: SASL_SSL
#        sasl.jaas.config: >-
#            org.apache.kafka.common.security.plain.PlainLoginModule required
#            username="username"
#            password="********";
#
#    # API-Key plan security configuration
#    apiKey:
#      securityMechanisms: PLAIN, SCRAM-SHA-256, SCRAM-SHA-512
#
#    # Kafka Network settings
#    port: 9092
#    host: 0.0.0.0
#    idleTimeout: 0
#    tcpKeepAlive: true
#    instances: 0
#    requestTimeout: 35_000 # default is 35_000 ms
#    # Forced to `true` when routingMode is `host`
#    secured: true
#    ssl:
#      # Forced to `true` when routingMode is `host`
#      sni: true
#      clientAuth: none # Supports none, request, required
#      tlsProtocols: TLSv1.2, TLSv1.3
#      tlsCiphers: TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
#      keystore:
#        type: jks # Supports jks, pem, pkcs12, self-signed
#        path: ${gravitee.home}/security/keystore.jks # A path is required if certificate's type is jks or pkcs12
#        certificates: # Certificates are required if keystore's type is pem
#          - cert: ${gravitee.home}/security/mycompany.org.pem
#            key: ${gravitee.home}/security/mycompany.org.key
#          - cert: ${gravitee.home}/security/mycompany.com.pem
#            key: ${gravitee.home}/security/mycompany.com.key
#        password: secret
#        watch: true # Watch for any updates on the keystore and reload it. Default is true.
#        defaultAlias: # Optional. Useful to target a particular key-pair when the keystore contains more than one.
#        # The following is for type 'pem', report to 'secrets' section for other secret-provider plugins.
#        # This method is now the preferred way for kubernetes: /namespace/secrets/my-tls-secret
#        secret: secret://kubernetes/my-tls-secret
#      truststore:
#        type: jks # Supports jks, pem, pkcs12, pem-folder (for the latter watch supports added/updated/removed files)
#        path: ${gravitee.home}/security/truststore.jks
#        password: secret
#        watch: true # Watch for any updates on the keystore/pem and reload it. Default is true.
#      openssl: false # Used to rely on OpenSSL Engine instead of default JDK SSL Engine

  logging:
    debug: false
    stdout:
      json: false
      encoderPattern: "%d{HH:mm:ss.SSS} [%thread] [%X{api}] %-5level %logger{36} - %msg%n"
    file:
      enabled: false
      rollingPolicy: |
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- daily rollover -->
            <fileNamePattern>${gravitee.home}/logs/gravitee_%d{yyyy-MM-dd}.log</fileNamePattern>
            <!-- keep 30 days' worth of history -->
            <maxHistory>30</maxHistory>
        </rollingPolicy>
      encoderPattern: "%d{HH:mm:ss.SSS} [%thread] [%X{api}] %-5level %logger{36} - %msg%n"
    graviteeLevel: DEBUG
    jettyLevel: WARN
  # If you provide your own gravitee.yml by using a volumeMount, reloadOnConfigChange is disabled.
  reloadOnConfigChange: true
  deployment:
    # Annotations to apply to the deployment
    annotations: {}
    # additionals labels
    labels: {}
    affinity: {}
    hostAliases: []
    #- ip: "127.0.0.1"
    #  hostnames:
    #  - "foo.local"
    #  - "bar.local"
    nodeSelector: {}
    tolerations: []
    envFrom: []
    # - configMapRef:
    #     name: config-secret
    # SecurityContext holds pod-level security attributes and common container settings.
    # Field values of container.securityContext take precedence over field values of PodSecurityContext.
    podSecurityContext:
     #fsGroup: 1001
     #runAsUser: 1001
     #runAsNonRoot: true
    # SecurityContext defines the security options the container should be run with.
    # If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext
    securityContext:
      runAsUser: 1001
      runAsNonRoot: true

    # Dedicated Service account provided for this component
    serviceAccount: ""
    strategy:
      type: RollingUpdate
      rollingUpdate:
        maxUnavailable: 1
    topologySpreadConstraints: []
    # revisionHistoryLimit: 10

    startupProbe:
      enabled: true

    # set startupProbe.enabled: false to define your own StartupProbe
    customStartupProbe: {}
    #  tcpSocket:
    #    port: http
    #  failureThreshold: 30
    #  periodSeconds: 10

    livenessProbe:
      enabled: true

    # set livenessProbe.enabled: false to define your own livenessProbe
    customLivenessProbe: {}
    #  tcpSocket:
    #    port: http
    #  initialDelaySeconds: 30
    #  periodSeconds: 30
    #  failureThreshold: 3

    readinessProbe:
      enabled: true

    # set readinessProbe.enabled: false to define your own readinessProbe
    customReadinessProbe: {}
    #  tcpSocket:
    #    port: http
    #  initialDelaySeconds: 10
    #  periodSeconds: 30
    #  failureThreshold: 3

  pdb:
    enabled: false
    minAvailable: ""
    maxUnavailable: "50%"

  podAnnotations: {}
    # iam.amazonaws.com/role: es-cluster

  # How long to wait for APIM Gateway pods to stop gracefully
  terminationGracePeriod: 30

  # This is the PriorityClass settings as defined in
  # https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass
  priorityClassName: ""

  additionalPlugins:
#    - https://path_to_plugin


  ssl:
    enabled: false
  #  keystore:
  #    type: jks # Supports jks, pem, pkcs12
  #    path: ${gravitee.home}/security/keystore.jks
  #    password: secret
    clientAuth: false # Supports false/none, request, true/requires
  #  truststore:
  #    type: jks # Supports jks, pem, pkcs12
  #    path: ${gravitee.home}/security/truststore.jks
  #    password: secret
  #  sni: true
  replicaCount: 1
  # sharding_tags:
  # tenant:
  websocket: false
#  haproxy: # Support for https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt
#    proxyProtocol: false
#    proxyProtocolTimeout: 10000
  ratelimit:
    # redis:
    #   host: redis
    #   port: 6379
    #   username: # Optional: Redis username for ACL authentication
    #   password:
    #   ssl: false
    #   hostnameVerificationAlgorithm: NONE
    #   trustAll: true # default value is true to keep backward compatibility but you should set it to false and configure a truststore for security concerns
    #   tlsProtocols: # List of TLS protocols to allow comma separated i.e: TLSv1.2, TLSv1.3
    #   tlsCiphers: # List of TLS ciphers to allow comma separated i.e: TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
    #   alpn: false
    #   openssl: false # Used to rely on OpenSSL Engine instead of default JDK SSL Engine
    #   # Keystore for redis mTLS (client certificate)
    #   keystore:
    #     type: pem # Supports jks, pem, pkcs12
    #     path: ${gravitee.home}/security/redis-keystore.jks # A path is required if certificate's type is jks or pkcs12
    #     password: secret
    #     keyPassword:
    #     alias:
    #     certificates: # Certificates are required if keystore's type is pem
    #       - cert: ${gravitee.home}/security/redis-mycompany.org.pem
    #         key: ${gravitee.home}/security/redis-mycompany.org.key
    #       - cert: ${gravitee.home}/security/redis-mycompany.com.pem
    #         key: ${gravitee.home}/security/redis-mycompany.com.key
    #   truststore:
    #     type: pem # Supports jks, pem, pkcs12
    #     path: ${gravitee.home}/security/redis-truststore.jks
    #     password: secret
    #     alias:
    #   sentinel:
    #     master: redis-master
    #     nodes:
    #       - host: sentinel1
    #         port: 26379
    #       - host: sentinel2
    #         port: 26379
    #   operation:
    #     timeout: 10 # in milliseconds
    #   tcp:
    #     connectTimeout: 5000 # in milliseconds
    #     idleTimeout: 0 # in milliseconds
  management:
      http:
      #  url: "https://bridge.example.com:18092"
      #  # default values
      #  keepAlive: true
      #  idleTimeout: 30000
      #  connectTimeout: 5000
      #  readTimeout: 10000
      #  useCompression: true
      #  clearTextUpgrade: true
      #  version: HTTP_1_1     # or HTTP_2
      #  # retry less and less often until we reach 60s (default)
      #  # formula is factor^attempt x delay
      #  # in this case retry occurs like this: 2s, 3s, 4.5s, 6.7s, 10.1s, 15,2s etc.
      #  connectionRetry:
      #    delaySec: 2
      #    maxDelaySec: 60
      #    backoffFactor: 1.5 # how exponential we get to 60s (1.0 means linear)
      #  authentication:
      #    type: none # or basic or jwt
      #    basic:
      #      username: admin
      #      password: adminadmin
      #    jwt:
      #      token: eyJhbGciOiJIUzI1NiI...
      #  ssl:
      #    # defaults
      #    ### beware: since 4.4 default is false (see upgrade guide)
      #    trustAll: false
      #    verifyHostname: true
      #    # custom config for mTLS
      #    keystore:
      #      type: pkcs12 # can be jks / pkcs12 / pem
      #      path: ${gravitee.home}/security/bridge/mtls-keystore.p12
      #      password: s3cr3t
      #      # for pem
      #      # certPath: ${gravitee.home}/security/mtls-bridge-cert.pem
      #      # keyPath: ${gravitee.home}/security/mtls-bridge-key.pem
      #      # certContent: secret://...  # or raw pem, same for key content
      #      # keyContent:
      #    # config for non public CAs
      #    truststore:
      #      type: pem # can be jks / pkcs12 / pem
      #      path: ${gravitee.home}/security/bridge/rootCA.pem
      #      # certContent: secret://...  # or raw pem, same for key content
      #      # for jks/pkcs12
      #      # password:
      #  proxy:
      #    enabled: true
      #    host: proxy.example.com
      #    port: 8080
      #    username: proxy
      #    password: pa$$w0rd
      #    type: HTTP
      #    # useSystemProxy: true # reuses apim-gateway proxy config for other services

  # system: {}
  services:
    core:
      http:
        enabled: true
        port: 18082
        host: 0.0.0.0
        authentication:
          type: basic
          password: adminadmin
        secured: false
        ssl:
          keystore:
            type: "PKCS12"
            path: "/p12/keystore"
            #password:
      ingress:
        enabled: false
        ingressClassName: ""
        pathType: Prefix
        path: /_(.*)
        hosts:
          - apim.example.com
        annotations: {}
#            kubernetes.io/ingress.class: nginx
#            nginx.ingress.kubernetes.io/rewrite-target: /_$1
      service:
#       If you choose to enable this service, you'll need to expose the technical api
#       on an accessible host outside of the pod: api.http.services.core.http.host
        enabled: false
#         type: ClusterIP
#         externalPort: 18082
#         appProtocol: http
    kafka:
      enabled: true # Activated if `gateway.kafka.enabled` are also be enabled
      service:
        externalPort: 9092
        internalPort: 9092
    bridge:
      enabled: false
      # host: localhost
      # # next two are deprecated, use authentication.users instead
      # username:
      # password:
      tcpKeepAlive: true
      # maxHeaderSize: 8192
      # maxChunkSize: 8192
      # alpn: true
      # authentication:
      #    type: basic # Supports: none, jwt
      #    users:
      #      admin: secret
      #      foo: bar
      #    jwt:
      #      signature:
      #        algorithm: RS256
      #        path: ${gravitee.home}/security/bridge/public_key.pem
      #        # path and value mutually exclusive
      #        value: <public key pem with headers>
      #      verifyClaims: true
      ssl:
        enabled: false
      #  keystore:
      #    type: jks # Supports jks, pem, pkcs12
      #    path: ${gravitee.home}/security/keystore.jks
      #    password: secret
      #    defaultAlias:
      #    secret: secret://kubernetes/bridge-tls
      #    watch: true
      #    # when type is 'pem'
      #    certificates:
      #      - cert: ${gravitee.home}/security/cert.pem
      #        key: ${gravitee.home}/security/key.pem
      #  clientAuth: none
      #  truststore:
      #    type: jks # Supports jks, pem, pkcs12
      #    path: ${gravitee.home}/security/truststore.jks
      #    password: secret
      #    secret: secret://kubernetes/bridge-mtls:ca.crt
      #    watch: true
      service:
        externalPort: 92
        internalPort: 18092
      #  appProtocol: http
      ingress:
        enabled: false
        ingressClassName: ""
        pathType: Prefix
        path: /_bridge
      #   # Used to create an Ingress record.
        hosts:
          - apim.example.com
        annotations: {}
      #     kubernetes.io/ingress.class: nginx
      #     nginx.ingress.kubernetes.io/ssl-redirect: "false"
      #     nginx.ingress.kubernetes.io/enable-rewrite-log: "true"
      #     kubernetes.io/app-root: /gateway
      #     kubernetes.io/rewrite-target: /gateway
      #     nginx.ingress.kubernetes.io/configuration-snippet: "etag on;\nproxy_pass_header ETag;\nproxy_set_header if-match \"\";\n"
      #     kubernetes.io/tls-acme: "true"
      #  tls:
          # Secrets must be manually created in the namespace.
      #    - secretName: chart-example-tls
      #      hosts:
      #        - chart-example.local
    metrics:
      enabled: false
      prometheus:
        enabled: true
        concurrencyLimit: 3
#   opentelemetry:
#      enabled: false
#      verbose: false
#      extraAttributes:
#        - deployment.environment.name: production
#      exporter:
#        endpoint: http://localhost:4317
#        protocol: grpc
#        compression: none
#        headers:
#          - X-Custom-Header: value
#        timeout: 10000
#        ssl:
#          trustall: false
#          verifyHostname: true
#          keystore:
#            type: pkcs12
#            path: /path/to/keystore
#            password: password
#          truststore:
#            type: pkcs12
#            path: /path/to/truststore
#            password: password

    sync:
      enabled: true
      #delay: 5000
      #unit: MILLISECONDS
      # Uncomment below for distributed sync (also uncomment distributedSync above)
      #repository:
      #  enabled: true
      #distributed:
      #  enabled: true

    healthcheck:
      jitterInMs: 900

    heartbeat:
      enabled: true
      delay: 5000
      unit: MILLISECONDS
## APIs specific configuration
#  api:
#    properties:
#      encryption:
#        secret: ...
## API Level secret-provider configuration
#    secrets:
#      providers:
#        # exists on all environments
#        - id: all                # uri starts with '/all/...'
#          plugin: vault
#          configuration:
#            enabled: false
#            host: 127.0.0.1
#            port: 8200
#            # namespace:
#            # kvEngine: V2                          # defaults to v2 can be "v1", no mixing supported
#            # readTimeoutSec: 2
#            # connectTimeoutSec: 3
#            ssl:
#              enabled: false                        # not for production
#              # format: "pemfile"                   # one of "pem","pemfile" "truststore"
#              # pem:                                # pem in base64 with headers
#              # file: /opt/gravitee/vault.pem       # for 'pemfile' and 'truststore'
#            auth:
#              method: token # one of "token", "github", "userpass", "approle", "cert" (mTLS)
#              config:
#                ### token config
#                # token:

#                ### github config
#                # token:
#                ## path: <non standard github mount path>

#                ### userpass config
#                # username:
#                # password:
#                ## path: <non standard userpass mount path>

#                ### approle
#                # roleId:
#                # secretId:
#                ## path: <non standard approle mount path>

#                ### cert
#                # format:        # one of "pem", "pemfile", "keystore"
#                ## path: <non standard cert mount path>
#                ## for 'pem' and 'pemfile' format
#                # cert:          # filename or inline cert
#                # key:           # filename or inline private key
#                ## for 'keystore' format
#                # keyStore:      # for "keystore": keystore filename
#                # password:      # keystore password
#        - plugin: kubernetes    # uri starts with '/kubernetes/...'
#          configuration:
#            enabled: true
#            # namespace: default   # if left empty will assume the namespace is the current namespace in which gravitee is deployed
#            # kubeConfigFile: /opt/gravitee/config/kube-config.json
#            # timeoutMs: 3000      # client timeout
#          environments:
#            - f5bd78b7-eec2-4c97-9d3a-cb73ec7e3e87
#            - 6654bb2f-1f07-4b55-b708-0d0fde18159e
#      retryOnError:
#        enabled: true
#        delay: 2
#        unit: SECONDS
#        backoffFactor: 1.5
#        maxDelay: 60
#        maxAttempt: 10
#      allowGeneratedSpecs: true
#      # Enables automatic renewal of the secret based on secrets TTL
#      renewal:
#        enabled: true # Default is false
#        # Check strategy to check if a secret is still valid
#        check:
#          delay: 1
#          unit: MINUTES
#        # TTL by default for all secrets
#        defaultSecretTtl:
#          delay: 1
#          unit: MINUTES
  # handlers:
  #   request:
  #     transaction:
  #       header: X-Gravitee-Transaction-Id
  #     request:
  #       header: X-Gravitee-Request-Id
#  reporters:
#    warnings:
#      enabled: true
#    elasticsearch:
#      enabled: true
#    tcp:
#      enabled: true
#      host: localhost
#      port: 8379
#    file:
  gracefulShutdown:
    delay: 0
    unit: MILLISECONDS

  classloader:
    legacy:
      enabled: false

  # DEPRECATED: This part will be removed shortly in favor of gateway.policy (see below)
  apiKey:
    header: X-Gravitee-Api-Key
    param: api-key

  #policy:
  #  api-key:
  #    header: X-Gravitee-Api-Key
  #    param: api-key

  image:
    repository: graviteeio/apim-gateway
    # tag: 3.0.2
    pullPolicy: Always
    # pullSecrets: gravitee_secrets
  env: []
  #   - name: ENV_VARIABLE
  #     value: ENV_VARIABLE_VALUE
  #   - name: ENV_VARIABLE_WITH_FROM
  #     valueFrom:
  #       configMapKeyRef:
  #         name: special-config
  #         key: SPECIAL_LEVEL
  service:
    type: ClusterIP
    # externalTrafficPolicy is used only when configuring type "NodePort" or "LoadBalancer"
    externalTrafficPolicy: Cluster
    externalPort: 82
    # used only if the type of your service is "NodePort" and must be in the range 30000-32767
    # if not set a random port will be used in that range
    # nodePort: 30082
    internalPort: 8082
    internalPortName: http
#    annotations:
#      loadbalancer.openstack.org/proxy-protocol: true
#    appProtocol: http
  # annotations:
  autoscaling:
    # When gateway.autoscaling.enabled is true, a HorizontalPodAutoscaler is created
    enabled: true
    minReplicas: 1
    maxReplicas: 3
    # warning: these two target utilization will be overwritten if gateway.autoscaling.metrics is defined.
    targetAverageUtilization: 50
    targetMemoryAverageUtilization: 80
    # here you can add specific annotations to this HPA
#    annotations:
    # If default CPU and Memory utilisation is not enough, you can here overwrite the metrics with your settings
    # @see: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
#    metrics:
    # Optionnaly you can also add behavior
    # @see: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#configurable-scaling-behavior
#    behavior:
  ingress:
    enabled: true
    pathType: Prefix
    path: /
    ingressClassName: ""
    # Used to create an Ingress record.
    # Multiple hostnames supported
    # - hosts:
    #     - chart-example.local
    #     - chart-example2.local
    hosts:
      - apim.example.com
    annotations:
      kubernetes.io/ingress.class: nginx
      # nginx.ingress.kubernetes.io/ssl-redirect: "false"
      # nginx.ingress.kubernetes.io/configuration-snippet: "etag on;\nproxy_pass_header ETag;\nproxy_set_header if-match \"\";\n"
      # kubernetes.io/tls-acme: "true"
    #tls:
      # Secrets must be manually created in the namespace.
    #  - hosts:
    #      - apim.example.com
    #    secretName: api-custom-cert
  resources:
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 200m
      memory: 256Mi
    #  lifecycle:
    #    postStart: '[ "/bin/sh", "-c", "echo Post starting Gravitee Gateway" ]'
    #    preStop: '[ "/bin/sh", "-c", "echo Pre stopping Gravitee Gateway" ]'
    ## Additional gravitee gateway volume mounts
    # Defines additional volume mounts.
  #extraVolumeMounts: |
  #  - name: extra-volume
  #    mountPath: /mnt/volume
  #    readOnly: true
  #
  # If you want to use your own gravitee.yml you have to provide your configmap or secret in extraVolume part.
  # the name of the volume MUST be "config".
  # In this case, values configuration related to gravitee.yaml defined in this file will be ignored
  # If you also define your own logback.xml in the "config" volume, you have to set logging.debug: false or your file will be ignored
  #extraVolumes: |
  #  - name: config
  #    configMap:
  #      name: gravitee-config-configmap-name
  #  - name: config
  #    secret:
  #      secretName: gravitee-config-secret-name
  # Gravitee Expression Language whitelist
  # These are the java classes / methods that are whitelisted for Gravitee Expression Language (SpEL) expressions:
  # https://github.com/gravitee-io/gravitee-expression-language/blob/master/src/main/resources/whitelist
  # Everything beyond must be explicitly whitelisted:
  #el:
  #  whitelist:
  #    mode: append
  #    list:
  #    - class java.io.ByteArrayInputStream
  #    - class java.util.regex.Pattern
  #    - class java.util.regex.Matcher
  #    - ...

portal:
  enabled: true
  name: portal
  replicaCount: 1
  image:
    repository: graviteeio/apim-portal-ui
    # tag: 3.0.2
    pullPolicy: Always
    # pullSecrets: gravitee_secrets

  lifecycle:
    preStop: "['sh','-c', 'sleep 5 && /usr/sbin/nginx -s quit']"
  deployment:
    # Annotations to apply to the deployment
    annotations: {}
    # additionals labels
    labels: {}
    affinity: {}
    hostAliases: []
    #- ip: "127.0.0.1"
    #  hostnames:
    #  - "foo.local"
    #  - "bar.local"
    nodeSelector: {}
    tolerations: []
    envFrom: []
    # - configMapRef:
    #     name: config-secret
    # SecurityContext holds pod-level security attributes and common container settings.
    # Field values of container.securityContext take precedence over field values of PodSecurityContext.
    podSecurityContext:
      #fsGroup: 1001
      #runAsUser: 1001
      #runAsNonRoot: true
    # SecurityContext defines the security options the container should be run with.
    # If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext
    securityContext:
      runAsUser: 101
      runAsGroup: 101
      runAsNonRoot: true
    # Dedicated Service account provided for this component
    serviceAccount: ""
    strategy:
      type: RollingUpdate
      rollingUpdate:
        maxUnavailable: 1
    topologySpreadConstraints: []
    # revisionHistoryLimit: 10

    livenessProbe:
      enabled: true
      httpGet:
        path: /
        port: http
      initialDelaySeconds: 10
      periodSeconds: 30
      failureThreshold: 3

    customLivenessProbe: {}

    readinessProbe:
      enabled: true
      httpGet:
        path: /
        port: http
      initialDelaySeconds: 10
      periodSeconds: 30
      failureThreshold: 3

    customReadinessProbe: {}

    startupProbe:
      enabled: false

    customStartupProbe: {}

  pdb:
    enabled: false
    minAvailable: ""
    maxUnavailable: "50%"

  podAnnotations: {}
    # iam.amazonaws.com/role: es-cluster

  # How long to wait for APIM Portal pods to stop gracefully
  terminationGracePeriod: 30

  # This is the PriorityClass settings as defined in
  # https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass
  priorityClassName: ""

  env: []
  #   - name: ENV_VARIABLE
  #     value: ENV_VARIABLE_VALUE
  #   - name: ENV_VARIABLE_WITH_FROM
  #     valueFrom:
  #       configMapKeyRef:
  #         name: special-config
  #         key: SPECIAL_LEVEL
  autoscaling:
    # When portal.autoscaling.enabled is true, a HorizontalPodAutoscaler is created
    enabled: true
    minReplicas: 1
    maxReplicas: 3
    # warning: these two target utilization will be overwritten if portal.autoscaling.metrics is defined.
    targetAverageUtilization: 50
    targetMemoryAverageUtilization: 80
    # here you can add specific annotations to this HPA
#    annotations:
    # If default CPU and Memory utilisation is not enough, you can here overwrite the metrics with your settings
    # @see: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
#    metrics:
    # Optionnaly you can also add behavior
    # @see: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#configurable-scaling-behavior
#    behavior:
  service:
    name: nginx
    type: ClusterIP
    # externalTrafficPolicy is used only when configuring type "NodePort" or "LoadBalancer"
    externalTrafficPolicy: Cluster
    externalPort: 8003
    internalPort: 8080
    # used only if the type of your service is "NodePort" and must be in the range 30000-32767
    # if not set a random port will be used in that range
    # nodePort: 30003
    internalPortName: http
#    appProtocol: http
  # annotations:
  ingress:
    enabled: true
    pathType: Prefix
    path: /
    ingressClassName: ""
    # Used to create an Ingress record.
    hosts:
      - apim.example.com
    annotations:
      kubernetes.io/ingress.class: nginx
      nginx.ingress.kubernetes.io/rewrite-target: /
    #tls:
      # Secrets must be manually created in the namespace.
    #  - hosts:
    #      - apim.example.com
    #    secretName: api-custom-cert
  resources:
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    limits:
      cpu: 100m
      memory: 128Mi
    requests:
      cpu: 50m
      memory: 64Mi
    #  lifecycle:
    #    postStart: '[ "/bin/sh", "-c", "echo Post starting Gravitee Portal" ]'
    #    preStop: '[ "/bin/sh", "-c", "echo Pre stopping Gravitee Portal" ]'
    ## Additional gravitee ui volume mounts
    # Defines additional volume mounts.
    # extraVolumeMounts: |
    # - name: extra-volume
    #   mountPath: /mnt/volume
    #   readOnly: true
  defaultPortal: "classic" # set value to "next" to use the new portal by default

  # If you want to use your own config.json you have to provide your configmap or secret in extraVolume part.
  # the name of the volume MUST be "config".
  # In this case, values configuration related to config.json defined in this file will be ignored
  #extraVolumes: |
  #  - name: config
  #    configMap:
  #      name: gravitee-config-configmap-name
  #  - name: config
  #    secret:
  #      secretName: gravitee-config-secret-name

ui:
  enabled: true
  name: ui
  companyName: Gravitee.io
  title: Management UI
  managementTitle: API Management
  documentationLink: https://documentation.gravitee.io/
  scheduler:
    tasks: 10
  theme:
    name: "default"
    logo: "assets/gravitee_logo_solaris.png"
    loader: "assets/gravitee_logo_anim.gif"
  portal:
    apikeyHeader: "X-Gravitee-Api-Key"
    userCreation:
      enabled: false
    support:
      enabled: true
    rating:
      enabled: false
    analytics:
      enabled: false
      trackingId: ""
  replicaCount: 1
  image:
    repository: graviteeio/apim-management-ui
    # tag: 3.0.2
    pullPolicy: Always
    # pullSecrets: gravitee_secrets

  lifecycle:
    preStop: "['sh','-c', 'sleep 5 && /usr/sbin/nginx -s quit']"
  deployment:
    # Annotations to apply to the deployment
    annotations: {}
    # additionals labels
    labels: {}
    affinity: {}
    hostAliases: []
    #- ip: "127.0.0.1"
    #  hostnames:
    #  - "foo.local"
    #  - "bar.local"
    nodeSelector: {}
    tolerations: []
    envFrom: []
    # - configMapRef:
    #     name: config-secret
    # SecurityContext holds pod-level security attributes and common container settings.
    # Field values of container.securityContext take precedence over field values of PodSecurityContext.
    podSecurityContext:
      #fsGroup: 1001
      #runAsUser: 1001
      #runAsNonRoot: true
    # SecurityContext defines the security options the container should be run with.
    # If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext
    securityContext:
      runAsUser: 101
      runAsGroup: 101
      runAsNonRoot: true
    # Dedicated Service account provided for this component
    serviceAccount: ""
    strategy:
      type: RollingUpdate
      rollingUpdate:
        maxUnavailable: 1
    topologySpreadConstraints: []
    # revisionHistoryLimit: 10

    livenessProbe:
      enabled: true
      httpGet:
        path: /
        port: http
      initialDelaySeconds: 10
      periodSeconds: 30
      failureThreshold: 3

    customLivenessProbe: {}

    readinessProbe:
      enabled: true
      httpGet:
        path: /
        port: http
      initialDelaySeconds: 10
      periodSeconds: 30
      failureThreshold: 3

    customReadinessProbe: {}

    startupProbe:
      enabled: false

    customStartupProbe: { }

  pdb:
    enabled: false
    minAvailable: ""
    maxUnavailable: "50%"

  podAnnotations: {}
    # iam.amazonaws.com/role: es-cluster

  # How long to wait for APIM Console pods to stop gracefully
  terminationGracePeriod: 30

  # This is the PriorityClass settings as defined in
  # https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass
  priorityClassName: ""

  env: []
  #   - name: ENV_VARIABLE
  #     value: ENV_VARIABLE_VALUE
  #   - name: ENV_VARIABLE_WITH_FROM
  #     valueFrom:
  #       configMapKeyRef:
  #         name: special-config
  #         key: SPECIAL_LEVEL
  autoscaling:
    # When ui.autoscaling.enabled is true, a HorizontalPodAutoscaler is created
    enabled: true
    minReplicas: 1
    maxReplicas: 3
    # warning: these two target utilization will be overwritten if ui.autoscaling.metrics is defined.
    targetAverageUtilization: 50
    targetMemoryAverageUtilization: 80
    # here you can add specific annotations to this HPA
#    annotations:
    # If default CPU and Memory utilisation is not enough, you can here overwrite the metrics with your settings
    # @see: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
#    metrics:
    # Optionnaly you can also add behavior
    # @see: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#configurable-scaling-behavior
#    behavior:
  service:
    name: nginx
    type: ClusterIP
    # externalTrafficPolicy is used only when configuring type "NodePort" or "LoadBalancer"
    externalTrafficPolicy: Cluster
    externalPort: 8002
    internalPort: 8080
    # used only if the type of your service is "NodePort" and must be in the range 30000-32767
    # if not set a random port will be used in that range
    # nodePort: 30002
    internalPortName: http
#    appProtocol: http
  # annotations:
  ingress:
    enabled: true
    pathType: ImplementationSpecific
    path: /console(/.*)?
    ingressClassName: ""
    # Used to create an Ingress record.
    hosts:
      - apim.example.com
    annotations:
      kubernetes.io/ingress.class: nginx
      nginx.ingress.kubernetes.io/rewrite-target: /$1
    # tls:
      # Secrets must be manually created in the namespace.
    #  - hosts:
    #      - apim.example.com
    #    secretName: api-custom-cert
  resources:
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    limits:
      cpu: 100m
      memory: 128Mi
    requests:
      cpu: 50m
      memory: 64Mi
    #  lifecycle:
    #    postStart: '[ "/bin/sh", "-c", "echo Post starting Gravitee UI" ]'
    #    preStop: '[ "/bin/sh", "-c", "echo Pre stopping Gravitee UI" ]'
    ## Additional gravitee ui volume mounts
    # Defines additional volume mounts.
    # extraVolumeMounts: |
    # - name: extra-volume
    #   mountPath: /mnt/volume
    #   readOnly: true
  # If you want to use your own constants.json you have to provide your configmap or secret in extraVolume part.
  # the name of the volume MUST be "config".
  # In this case, values configuration related to constants.json defined in this file will be ignored
  #extraVolumes: |
  #  - name: config
  #    configMap:
  #      name: gravitee-config-configmap-name
  #  - name: config
  #    secret:
  #      secretName: gravitee-config-secret-name

# NOTE: Kafka Console is in tech preview and requires a private image.
# Contact your technical account manager for access and the correct image reference.
kafkaConsole:
  enabled: false
  name: kafkaConsole
  replicaCount: 1
  image:
    repository: graviteeio/apim-kafka-console # Update with your private registry
    # tag: latest
    pullPolicy: Always

  lifecycle:
    preStop: "['sh','-c', 'sleep 5 && /usr/sbin/nginx -s quit']"
  deployment:
    # Annotations to apply to the deployment
    annotations: {}
    # additionals labels
    labels: {}
    affinity: {}
    hostAliases: []
    #- ip: "127.0.0.1"
    #  hostnames:
    #  - "foo.local"
    #  - "bar.local"
    nodeSelector: {}
    tolerations: []
    envFrom: []
    # - configMapRef:
    #     name: config-secret
    # SecurityContext holds pod-level security attributes and common container settings.
    # Field values of container.securityContext take precedence over field values of PodSecurityContext.
    podSecurityContext:
    #fsGroup: 1001
    #runAsUser: 1001
    #runAsNonRoot: true
    # SecurityContext defines the security options the container should be run with.
    # If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext
    securityContext:
      runAsUser: 101
      runAsGroup: 101
      runAsNonRoot: true
    # Dedicated Service account provided for this component
    serviceAccount: ""
    strategy:
      type: RollingUpdate
      rollingUpdate:
        maxUnavailable: 1
    topologySpreadConstraints: []
    # revisionHistoryLimit: 10

    livenessProbe:
      enabled: true
      httpGet:
        path: /
        port: http
      initialDelaySeconds: 10
      periodSeconds: 30
      failureThreshold: 3

    customLivenessProbe: {}

    readinessProbe:
      enabled: true
      httpGet:
        path: /
        port: http
      initialDelaySeconds: 10
      periodSeconds: 30
      failureThreshold: 3

    customReadinessProbe: {}

    startupProbe:
      enabled: false

    customStartupProbe: {}

  pdb:
    enabled: false
    minAvailable: ""
    maxUnavailable: "50%"

  podAnnotations: {}
  # iam.amazonaws.com/role: es-cluster

  # How long to wait for APIM Portal pods to stop gracefully
  terminationGracePeriod: 30

  # This is the PriorityClass settings as defined in
  # https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass
  priorityClassName: ""

  env: []
  #   - name: ENV_VARIABLE
  #     value: ENV_VARIABLE_VALUE
  #   - name: ENV_VARIABLE_WITH_FROM
  #     valueFrom:
  #       configMapKeyRef:
  #         name: special-config
  #         key: SPECIAL_LEVEL
  autoscaling:
    # When portal.autoscaling.enabled is true, a HorizontalPodAutoscaler is created
    enabled: true
    minReplicas: 1
    maxReplicas: 3
    # warning: these two target utilization will be overwritten if portal.autoscaling.metrics is defined.
    targetAverageUtilization: 50
    targetMemoryAverageUtilization: 80
    # here you can add specific annotations to this HPA
    #    annotations:
    # If default CPU and Memory utilisation is not enough, you can here overwrite the metrics with your settings
    # @see: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
    #    metrics:
    # Optionnaly you can also add behavior
    # @see: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#configurable-scaling-behavior
  #    behavior:
  service:
    name: nginx
    type: ClusterIP
    # externalTrafficPolicy is used only when configuring type "NodePort" or "LoadBalancer"
    externalTrafficPolicy: Cluster
    externalPort: 8004
    internalPort: 8080
    # used only if the type of your service is "NodePort" and must be in the range 30000-32767
    # if not set a random port will be used in that range
    # nodePort: 30003
    internalPortName: http
  #    appProtocol: http
  # annotations:
  resources:
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    limits:
      cpu: 500m
      memory: 1024Mi
    requests:
      cpu: 200m
      memory: 512Mi
    #  lifecycle:
    #    postStart: '[ "/bin/sh", "-c", "echo Post starting Gravitee Portal" ]'
    #    preStop: '[ "/bin/sh", "-c", "echo Pre stopping Gravitee Portal" ]'

  # Defines additional volume mounts.
  #extraVolumeMounts: |
  #  - name: extra-volume
  #    mountPath: /mnt/volume
  #    readOnly: true
  #

  # Defines additional volumes.
  #extraVolumes: |
  #  - name: config
  #    configMap:
  #      name: gravitee-config-configmap-name
  #  - name: cert
  #    secret:
  #      secretName: gravitee-cert-secret-name

  jwt:
    secret:
      value: # put here a 32bits string. It's used to signed JWT token for communication between management API and kafka console
  #    valueFrom:
  #      secretKeyRef:
  #        name:
  #        key:

  apim:
  #  apiUrl: # put here the URL to your management API. This should contain the organization and the environment information. If provided, `organization` & `environment` fields will be ignored. Example: https://my.company.com:8083/organizations/6eb27b47-2560-481f-b27b-472560581fff/environments/808a51a9-48f5-4517-8a51-a948f5e517b3
    organization: DEFAULT
    environment: DEFAULT
    security:
      username: admin # put here an org admin username. Ignored if token is provided
      password: admin # put here an org admin password. Ignored if token is provided
  #    token:
  #      value: # put here an org admin Personal Access Token. It replaces username and password
  #      valueFrom:
  #        secretKeyRef:
  #          name:
  #          key:


#secrets:
#  loadFirst: kubernetes
#  kubernetes:
#    enabled: true
#    namespace: default
#    kubeConfigFile: /opt/gravitee/config/kube-config.json
#    timeoutMs: 3000
#  vault:
#    enabled: false
#    host: 127.0.0.1
#    port: 8200
#    namespace:
#      kvEngine: V2
#      readTimeoutSec: 2
#      connectTimeoutSec: 3
#    ssl:
#      enabled: false
#    auth:
#      method: token
#      config:
#        token: aToken
#    retry:
#      attempts: 2
#      intervalMs: 1000
#    watch:
#      enabled: true
#      pollIntervalSec: 30

# Enabling openshift support will update ingresses annotations for not containing "kubernetes.io/ingress.class" which
# has to be removed to ensure OpenShift is creating a Route from the Ingress
openshift:
  enabled: false

initContainers:
  image: alpine:latest
  imagePullPolicy: Always
  securityContext:
    runAsUser: 1001
    runAsNonRoot: true
  env: []

# For enterprise plugin only, you will need a license
license:
  name: licensekey-apim
#  key: <put here your license.key file encoded in base64>
