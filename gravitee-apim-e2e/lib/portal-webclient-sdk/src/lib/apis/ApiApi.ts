/* tslint:disable */
/* eslint-disable */
/**
 * Gravitee.io Portal Rest API
 * API dedicated to the devportal part of Gravitee
 *
 * Contact: contact@graviteesource.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Api,
    ApiFromJSON,
    ApiToJSON,
    ApiMetrics,
    ApiMetricsFromJSON,
    ApiMetricsToJSON,
    ApisResponse,
    ApisResponseFromJSON,
    ApisResponseToJSON,
    ApplicationsResponse,
    ApplicationsResponseFromJSON,
    ApplicationsResponseToJSON,
    CategoriesResponse,
    CategoriesResponseFromJSON,
    CategoriesResponseToJSON,
    ErrorResponse,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    FilterApiQuery,
    FilterApiQueryFromJSON,
    FilterApiQueryToJSON,
    LinksResponse,
    LinksResponseFromJSON,
    LinksResponseToJSON,
    Page,
    PageFromJSON,
    PageToJSON,
    PagesResponse,
    PagesResponseFromJSON,
    PagesResponseToJSON,
    PlansResponse,
    PlansResponseFromJSON,
    PlansResponseToJSON,
    Rating,
    RatingFromJSON,
    RatingToJSON,
    RatingAnswerInput,
    RatingAnswerInputFromJSON,
    RatingAnswerInputToJSON,
    RatingInput,
    RatingInputFromJSON,
    RatingInputToJSON,
    RatingsResponse,
    RatingsResponseFromJSON,
    RatingsResponseToJSON,
} from '../models';

export interface CreateApiRatingRequest {
    apiId: string;
    ratingInput?: RatingInput;
}

export interface CreateApiRatingAnswerRequest {
    apiId: string;
    ratingId: string;
    ratingAnswerInput?: RatingAnswerInput;
}

export interface DeleteApiRatingRequest {
    apiId: string;
    ratingId: string;
}

export interface DeleteApiRatingAnswerRequest {
    apiId: string;
    ratingId: string;
    answerId: string;
}

export interface GetApiByApiIdRequest {
    apiId: string;
    include?: Array<GetApiByApiIdIncludeEnum>;
}

export interface GetApiLinksRequest {
    apiId: string;
}

export interface GetApiMediaRequest {
    apiId: string;
    mediaHash: string;
}

export interface GetApiMetricsByApiIdRequest {
    apiId: string;
}

export interface GetApiPlansByApiIdRequest {
    apiId: string;
    page?: number;
    size?: number;
}

export interface GetApiRatingsByApiIdRequest {
    apiId: string;
    page?: number;
    size?: number;
    mine?: boolean;
    order?: string;
}

export interface GetApisRequest {
    page?: number;
    size?: number;
    contextPath?: string;
    label?: string;
    version?: string;
    name?: string;
    category?: string;
    filter?: FilterApiQuery;
    filter2?: FilterApiQuery;
    promoted?: boolean;
}

export interface GetBackgroundByApiIdRequest {
    apiId: string;
}

export interface GetPageByApiIdAndPageIdRequest {
    apiId: string;
    pageId: string;
    include?: Array<GetPageByApiIdAndPageIdIncludeEnum>;
}

export interface GetPageContentByApiIdAndPageIdRequest {
    apiId: string;
    pageId: string;
}

export interface GetPagesByApiIdRequest {
    apiId: string;
    page?: number;
    size?: number;
    homepage?: boolean;
    parent?: string;
}

export interface GetPictureByApiIdRequest {
    apiId: string;
}

export interface GetSubscriberApplicationsByApiIdRequest {
    apiId: string;
    page?: number;
    size?: number;
    statuses?: Array<GetSubscriberApplicationsByApiIdStatusesEnum>;
}

export interface ListCategoriesRequest {
    filter?: FilterApiQuery;
}

export interface SearchApisRequest {
    page?: number;
    size?: number;
    q: string;
}

export interface UpdateApiRatingRequest {
    apiId: string;
    ratingId: string;
    ratingInput?: RatingInput;
}

/**
 * 
 */
export class ApiApi extends runtime.BaseAPI {

    /**
     * Create a rating for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned.  The current must have API_RATING[CREATE] permission to create a rating. 
     * Create a rating for an API
     */
    async createApiRatingRaw(requestParameters: CreateApiRatingRequest): Promise<runtime.ApiResponse<Rating>> {
        if (requestParameters.apiId === null || requestParameters.apiId === undefined) {
            throw new runtime.RequiredError('apiId','Required parameter requestParameters.apiId was null or undefined when calling createApiRating.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/apis/{apiId}/ratings`.replace(`{${"apiId"}}`, encodeURIComponent(String(requestParameters.apiId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RatingInputToJSON(requestParameters.ratingInput),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RatingFromJSON(jsonValue));
    }

    /**
     * Create a rating for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned.  The current must have API_RATING[CREATE] permission to create a rating. 
     * Create a rating for an API
     */
    async createApiRating(requestParameters: CreateApiRatingRequest): Promise<Rating> {
        const response = await this.createApiRatingRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create an answer to rating of API.  This API has to be accessible by the current user, otherwise a 404 will be returned.  The current must have API_RATING_ANSWER[CREATE] permission to create an answer. 
     * Create an answer to rating
     */
    async createApiRatingAnswerRaw(requestParameters: CreateApiRatingAnswerRequest): Promise<runtime.ApiResponse<Rating>> {
        if (requestParameters.apiId === null || requestParameters.apiId === undefined) {
            throw new runtime.RequiredError('apiId','Required parameter requestParameters.apiId was null or undefined when calling createApiRatingAnswer.');
        }

        if (requestParameters.ratingId === null || requestParameters.ratingId === undefined) {
            throw new runtime.RequiredError('ratingId','Required parameter requestParameters.ratingId was null or undefined when calling createApiRatingAnswer.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/apis/{apiId}/ratings/{ratingId}/answers`.replace(`{${"apiId"}}`, encodeURIComponent(String(requestParameters.apiId))).replace(`{${"ratingId"}}`, encodeURIComponent(String(requestParameters.ratingId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RatingAnswerInputToJSON(requestParameters.ratingAnswerInput),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RatingFromJSON(jsonValue));
    }

    /**
     * Create an answer to rating of API.  This API has to be accessible by the current user, otherwise a 404 will be returned.  The current must have API_RATING_ANSWER[CREATE] permission to create an answer. 
     * Create an answer to rating
     */
    async createApiRatingAnswer(requestParameters: CreateApiRatingAnswerRequest): Promise<Rating> {
        const response = await this.createApiRatingAnswerRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete a rating for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned.  The current must have API_RATING[DELETE] permission to delete a rating. 
     * Delete a rating for an API
     */
    async deleteApiRatingRaw(requestParameters: DeleteApiRatingRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.apiId === null || requestParameters.apiId === undefined) {
            throw new runtime.RequiredError('apiId','Required parameter requestParameters.apiId was null or undefined when calling deleteApiRating.');
        }

        if (requestParameters.ratingId === null || requestParameters.ratingId === undefined) {
            throw new runtime.RequiredError('ratingId','Required parameter requestParameters.ratingId was null or undefined when calling deleteApiRating.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/apis/{apiId}/ratings/{ratingId}`.replace(`{${"apiId"}}`, encodeURIComponent(String(requestParameters.apiId))).replace(`{${"ratingId"}}`, encodeURIComponent(String(requestParameters.ratingId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a rating for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned.  The current must have API_RATING[DELETE] permission to delete a rating. 
     * Delete a rating for an API
     */
    async deleteApiRating(requestParameters: DeleteApiRatingRequest): Promise<void> {
        await this.deleteApiRatingRaw(requestParameters);
    }

    /**
     * Delete an answer rating for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned.  The current must have API_RATING_ANSWER[DELETE] permission to delete a rating. 
     * Delete an answer rating for an API
     */
    async deleteApiRatingAnswerRaw(requestParameters: DeleteApiRatingAnswerRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.apiId === null || requestParameters.apiId === undefined) {
            throw new runtime.RequiredError('apiId','Required parameter requestParameters.apiId was null or undefined when calling deleteApiRatingAnswer.');
        }

        if (requestParameters.ratingId === null || requestParameters.ratingId === undefined) {
            throw new runtime.RequiredError('ratingId','Required parameter requestParameters.ratingId was null or undefined when calling deleteApiRatingAnswer.');
        }

        if (requestParameters.answerId === null || requestParameters.answerId === undefined) {
            throw new runtime.RequiredError('answerId','Required parameter requestParameters.answerId was null or undefined when calling deleteApiRatingAnswer.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/apis/{apiId}/ratings/{ratingId}/answers/{answerId}`.replace(`{${"apiId"}}`, encodeURIComponent(String(requestParameters.apiId))).replace(`{${"ratingId"}}`, encodeURIComponent(String(requestParameters.ratingId))).replace(`{${"answerId"}}`, encodeURIComponent(String(requestParameters.answerId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an answer rating for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned.  The current must have API_RATING_ANSWER[DELETE] permission to delete a rating. 
     * Delete an answer rating for an API
     */
    async deleteApiRatingAnswer(requestParameters: DeleteApiRatingAnswerRequest): Promise<void> {
        await this.deleteApiRatingAnswerRaw(requestParameters);
    }

    /**
     * Get the detail of an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * Get the API definition
     */
    async getApiByApiIdRaw(requestParameters: GetApiByApiIdRequest): Promise<runtime.ApiResponse<Api>> {
        if (requestParameters.apiId === null || requestParameters.apiId === undefined) {
            throw new runtime.RequiredError('apiId','Required parameter requestParameters.apiId was null or undefined when calling getApiByApiId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.include) {
            queryParameters['include'] = requestParameters.include;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/apis/{apiId}`.replace(`{${"apiId"}}`, encodeURIComponent(String(requestParameters.apiId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiFromJSON(jsonValue));
    }

    /**
     * Get the detail of an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * Get the API definition
     */
    async getApiByApiId(requestParameters: GetApiByApiIdRequest): Promise<Api> {
        const response = await this.getApiByApiIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get all the links (internal and external) to be displayed in the detail of the API. 
     * Get the API links from Aside SYSTEM_FOLDER.
     */
    async getApiLinksRaw(requestParameters: GetApiLinksRequest): Promise<runtime.ApiResponse<LinksResponse>> {
        if (requestParameters.apiId === null || requestParameters.apiId === undefined) {
            throw new runtime.RequiredError('apiId','Required parameter requestParameters.apiId was null or undefined when calling getApiLinks.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/{apiId}/links`.replace(`{${"apiId"}}`, encodeURIComponent(String(requestParameters.apiId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LinksResponseFromJSON(jsonValue));
    }

    /**
     * Get all the links (internal and external) to be displayed in the detail of the API. 
     * Get the API links from Aside SYSTEM_FOLDER.
     */
    async getApiLinks(requestParameters: GetApiLinksRequest): Promise<LinksResponse> {
        const response = await this.getApiLinksRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get api media. 
     * Get the api media.
     */
    async getApiMediaRaw(requestParameters: GetApiMediaRequest): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.apiId === null || requestParameters.apiId === undefined) {
            throw new runtime.RequiredError('apiId','Required parameter requestParameters.apiId was null or undefined when calling getApiMedia.');
        }

        if (requestParameters.mediaHash === null || requestParameters.mediaHash === undefined) {
            throw new runtime.RequiredError('mediaHash','Required parameter requestParameters.mediaHash was null or undefined when calling getApiMedia.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/{apiId}/media/{mediaHash}`.replace(`{${"apiId"}}`, encodeURIComponent(String(requestParameters.apiId))).replace(`{${"mediaHash"}}`, encodeURIComponent(String(requestParameters.mediaHash))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Get api media. 
     * Get the api media.
     */
    async getApiMedia(requestParameters: GetApiMediaRequest): Promise<Blob> {
        const response = await this.getApiMediaRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get some metrics about an API :   * number of subscribers   * number of hits during the last 7 days   * health ratio over the last week  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * Get API metrics
     */
    async getApiMetricsByApiIdRaw(requestParameters: GetApiMetricsByApiIdRequest): Promise<runtime.ApiResponse<ApiMetrics>> {
        if (requestParameters.apiId === null || requestParameters.apiId === undefined) {
            throw new runtime.RequiredError('apiId','Required parameter requestParameters.apiId was null or undefined when calling getApiMetricsByApiId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/{apiId}/metrics`.replace(`{${"apiId"}}`, encodeURIComponent(String(requestParameters.apiId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiMetricsFromJSON(jsonValue));
    }

    /**
     * Get some metrics about an API :   * number of subscribers   * number of hits during the last 7 days   * health ratio over the last week  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * Get API metrics
     */
    async getApiMetricsByApiId(requestParameters: GetApiMetricsByApiIdRequest): Promise<ApiMetrics> {
        const response = await this.getApiMetricsByApiIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * List plans for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * List plans for an API
     */
    async getApiPlansByApiIdRaw(requestParameters: GetApiPlansByApiIdRequest): Promise<runtime.ApiResponse<PlansResponse>> {
        if (requestParameters.apiId === null || requestParameters.apiId === undefined) {
            throw new runtime.RequiredError('apiId','Required parameter requestParameters.apiId was null or undefined when calling getApiPlansByApiId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/{apiId}/plans`.replace(`{${"apiId"}}`, encodeURIComponent(String(requestParameters.apiId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PlansResponseFromJSON(jsonValue));
    }

    /**
     * List plans for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * List plans for an API
     */
    async getApiPlansByApiId(requestParameters: GetApiPlansByApiIdRequest): Promise<PlansResponse> {
        const response = await this.getApiPlansByApiIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * List ratings for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * List ratings for an API
     */
    async getApiRatingsByApiIdRaw(requestParameters: GetApiRatingsByApiIdRequest): Promise<runtime.ApiResponse<RatingsResponse>> {
        if (requestParameters.apiId === null || requestParameters.apiId === undefined) {
            throw new runtime.RequiredError('apiId','Required parameter requestParameters.apiId was null or undefined when calling getApiRatingsByApiId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.mine !== undefined) {
            queryParameters['mine'] = requestParameters.mine;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/{apiId}/ratings`.replace(`{${"apiId"}}`, encodeURIComponent(String(requestParameters.apiId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RatingsResponseFromJSON(jsonValue));
    }

    /**
     * List ratings for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * List ratings for an API
     */
    async getApiRatingsByApiId(requestParameters: GetApiRatingsByApiIdRequest): Promise<RatingsResponse> {
        const response = await this.getApiRatingsByApiIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * List public APIs for anonymous requests. List all the APIs the current user is allowed to category for authenticated requests.  The list can be filtered according to query parameters.  By default the list is sorted by alphabetic order. If a **cat** query param is sent, a specific sorting can be applied. Please refer to **cat** description for detail. 
     * List APIs
     */
    async getApisRaw(requestParameters: GetApisRequest): Promise<runtime.ApiResponse<ApisResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.contextPath !== undefined) {
            queryParameters['context-path'] = requestParameters.contextPath;
        }

        if (requestParameters.label !== undefined) {
            queryParameters['label'] = requestParameters.label;
        }

        if (requestParameters.version !== undefined) {
            queryParameters['version'] = requestParameters.version;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.category !== undefined) {
            queryParameters['category'] = requestParameters.category;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.filter2 !== undefined) {
            queryParameters['-filter'] = requestParameters.filter2;
        }

        if (requestParameters.promoted !== undefined) {
            queryParameters['promoted'] = requestParameters.promoted;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/apis`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ApisResponseFromJSON(jsonValue));
    }

    /**
     * List public APIs for anonymous requests. List all the APIs the current user is allowed to category for authenticated requests.  The list can be filtered according to query parameters.  By default the list is sorted by alphabetic order. If a **cat** query param is sent, a specific sorting can be applied. Please refer to **cat** description for detail. 
     * List APIs
     */
    async getApis(requestParameters: GetApisRequest): Promise<ApisResponse> {
        const response = await this.getApisRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get the API\'s background.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * Get the API\'s background
     */
    async getBackgroundByApiIdRaw(requestParameters: GetBackgroundByApiIdRequest): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.apiId === null || requestParameters.apiId === undefined) {
            throw new runtime.RequiredError('apiId','Required parameter requestParameters.apiId was null or undefined when calling getBackgroundByApiId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/{apiId}/background`.replace(`{${"apiId"}}`, encodeURIComponent(String(requestParameters.apiId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Get the API\'s background.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * Get the API\'s background
     */
    async getBackgroundByApiId(requestParameters: GetBackgroundByApiIdRequest): Promise<Blob> {
        const response = await this.getBackgroundByApiIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get an API page.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * Get an API page
     */
    async getPageByApiIdAndPageIdRaw(requestParameters: GetPageByApiIdAndPageIdRequest): Promise<runtime.ApiResponse<Page>> {
        if (requestParameters.apiId === null || requestParameters.apiId === undefined) {
            throw new runtime.RequiredError('apiId','Required parameter requestParameters.apiId was null or undefined when calling getPageByApiIdAndPageId.');
        }

        if (requestParameters.pageId === null || requestParameters.pageId === undefined) {
            throw new runtime.RequiredError('pageId','Required parameter requestParameters.pageId was null or undefined when calling getPageByApiIdAndPageId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.include) {
            queryParameters['include'] = requestParameters.include;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/{apiId}/pages/{pageId}`.replace(`{${"apiId"}}`, encodeURIComponent(String(requestParameters.apiId))).replace(`{${"pageId"}}`, encodeURIComponent(String(requestParameters.pageId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PageFromJSON(jsonValue));
    }

    /**
     * Get an API page.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * Get an API page
     */
    async getPageByApiIdAndPageId(requestParameters: GetPageByApiIdAndPageIdRequest): Promise<Page> {
        const response = await this.getPageByApiIdAndPageIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get the content of a specific API documentation page.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * Get the content of an API page.
     */
    async getPageContentByApiIdAndPageIdRaw(requestParameters: GetPageContentByApiIdAndPageIdRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.apiId === null || requestParameters.apiId === undefined) {
            throw new runtime.RequiredError('apiId','Required parameter requestParameters.apiId was null or undefined when calling getPageContentByApiIdAndPageId.');
        }

        if (requestParameters.pageId === null || requestParameters.pageId === undefined) {
            throw new runtime.RequiredError('pageId','Required parameter requestParameters.pageId was null or undefined when calling getPageContentByApiIdAndPageId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/{apiId}/pages/{pageId}/content`.replace(`{${"apiId"}}`, encodeURIComponent(String(requestParameters.apiId))).replace(`{${"pageId"}}`, encodeURIComponent(String(requestParameters.pageId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Get the content of a specific API documentation page.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * Get the content of an API page.
     */
    async getPageContentByApiIdAndPageId(requestParameters: GetPageContentByApiIdAndPageIdRequest): Promise<string> {
        const response = await this.getPageContentByApiIdAndPageIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * List all documentation pages of an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * List API pages
     */
    async getPagesByApiIdRaw(requestParameters: GetPagesByApiIdRequest): Promise<runtime.ApiResponse<PagesResponse>> {
        if (requestParameters.apiId === null || requestParameters.apiId === undefined) {
            throw new runtime.RequiredError('apiId','Required parameter requestParameters.apiId was null or undefined when calling getPagesByApiId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.homepage !== undefined) {
            queryParameters['homepage'] = requestParameters.homepage;
        }

        if (requestParameters.parent !== undefined) {
            queryParameters['parent'] = requestParameters.parent;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/{apiId}/pages`.replace(`{${"apiId"}}`, encodeURIComponent(String(requestParameters.apiId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PagesResponseFromJSON(jsonValue));
    }

    /**
     * List all documentation pages of an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * List API pages
     */
    async getPagesByApiId(requestParameters: GetPagesByApiIdRequest): Promise<PagesResponse> {
        const response = await this.getPagesByApiIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get the API\'s picture.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * Get the API\'s picture
     */
    async getPictureByApiIdRaw(requestParameters: GetPictureByApiIdRequest): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.apiId === null || requestParameters.apiId === undefined) {
            throw new runtime.RequiredError('apiId','Required parameter requestParameters.apiId was null or undefined when calling getPictureByApiId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/{apiId}/picture`.replace(`{${"apiId"}}`, encodeURIComponent(String(requestParameters.apiId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Get the API\'s picture.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * Get the API\'s picture
     */
    async getPictureByApiId(requestParameters: GetPictureByApiIdRequest): Promise<Blob> {
        const response = await this.getPictureByApiIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * If the current user is the owner of the API, all connected applications will be returned. Filtered by status. Ordered by number of hits. Else only applications that current is allowed to access will.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * List applications that subscribred to an API
     */
    async getSubscriberApplicationsByApiIdRaw(requestParameters: GetSubscriberApplicationsByApiIdRequest): Promise<runtime.ApiResponse<ApplicationsResponse>> {
        if (requestParameters.apiId === null || requestParameters.apiId === undefined) {
            throw new runtime.RequiredError('apiId','Required parameter requestParameters.apiId was null or undefined when calling getSubscriberApplicationsByApiId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.statuses) {
            queryParameters['statuses'] = requestParameters.statuses;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/{apiId}/subscribers`.replace(`{${"apiId"}}`, encodeURIComponent(String(requestParameters.apiId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationsResponseFromJSON(jsonValue));
    }

    /**
     * If the current user is the owner of the API, all connected applications will be returned. Filtered by status. Ordered by number of hits. Else only applications that current is allowed to access will.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * List applications that subscribred to an API
     */
    async getSubscriberApplicationsByApiId(requestParameters: GetSubscriberApplicationsByApiIdRequest): Promise<ApplicationsResponse> {
        const response = await this.getSubscriberApplicationsByApiIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * For anonymous requests, list all categories of public APIs. For authenticated requests, list all categories of all the APIs the current user can access.  The list is sorted by alphabetic order. 
     * List Categories
     */
    async listCategoriesRaw(requestParameters: ListCategoriesRequest): Promise<runtime.ApiResponse<CategoriesResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/categories`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CategoriesResponseFromJSON(jsonValue));
    }

    /**
     * For anonymous requests, list all categories of public APIs. For authenticated requests, list all categories of all the APIs the current user can access.  The list is sorted by alphabetic order. 
     * List Categories
     */
    async listCategories(requestParameters: ListCategoriesRequest): Promise<CategoriesResponse> {
        const response = await this.listCategoriesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Same as `/apis` but with a search query as a parameter. Search for API using the search engine. Supports pagination. 
     * Search APIs with a query
     */
    async searchApisRaw(requestParameters: SearchApisRequest): Promise<runtime.ApiResponse<ApisResponse>> {
        if (requestParameters.q === null || requestParameters.q === undefined) {
            throw new runtime.RequiredError('q','Required parameter requestParameters.q was null or undefined when calling searchApis.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/apis/_search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ApisResponseFromJSON(jsonValue));
    }

    /**
     * Same as `/apis` but with a search query as a parameter. Search for API using the search engine. Supports pagination. 
     * Search APIs with a query
     */
    async searchApis(requestParameters: SearchApisRequest): Promise<ApisResponse> {
        const response = await this.searchApisRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update a rating for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned.  The current must have API_RATING[CREATE] permission to update a rating. 
     * Update a rating for an API
     */
    async updateApiRatingRaw(requestParameters: UpdateApiRatingRequest): Promise<runtime.ApiResponse<Rating>> {
        if (requestParameters.apiId === null || requestParameters.apiId === undefined) {
            throw new runtime.RequiredError('apiId','Required parameter requestParameters.apiId was null or undefined when calling updateApiRating.');
        }

        if (requestParameters.ratingId === null || requestParameters.ratingId === undefined) {
            throw new runtime.RequiredError('ratingId','Required parameter requestParameters.ratingId was null or undefined when calling updateApiRating.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/apis/{apiId}/ratings/{ratingId}`.replace(`{${"apiId"}}`, encodeURIComponent(String(requestParameters.apiId))).replace(`{${"ratingId"}}`, encodeURIComponent(String(requestParameters.ratingId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RatingInputToJSON(requestParameters.ratingInput),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RatingFromJSON(jsonValue));
    }

    /**
     * Update a rating for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned.  The current must have API_RATING[CREATE] permission to update a rating. 
     * Update a rating for an API
     */
    async updateApiRating(requestParameters: UpdateApiRatingRequest): Promise<Rating> {
        const response = await this.updateApiRatingRaw(requestParameters);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum GetApiByApiIdIncludeEnum {
    Pages = 'pages',
    Plans = 'plans'
}
/**
    * @export
    * @enum {string}
    */
export enum GetPageByApiIdAndPageIdIncludeEnum {
    Content = 'content'
}
/**
    * @export
    * @enum {string}
    */
export enum GetSubscriberApplicationsByApiIdStatusesEnum {
    ACCEPTED = 'ACCEPTED',
    CLOSED = 'CLOSED',
    PAUSED = 'PAUSED',
    PENDING = 'PENDING',
    REJECTED = 'REJECTED'
}
